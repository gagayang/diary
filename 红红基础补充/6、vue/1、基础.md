## 1.生命周期

如图：./image/1、基础/vue生命周期.png

父beforeCreate => 父created => 父beforeMount =>
子beforeCreate => 子created =>子beforeMount => 子Mounted=>父Mounted

子组件先挂载 然后到父组件,更新也类似
父beforeUpdate =>子beforeUpdate => 子updated => 父updated

2.父子组件传值

vue2为例： `$emit`,`props`,`$ref`,`$parent`,`$children`, `eventBus`, `provide/inject`, `vuex`

#### 14、Vuex有哪些基本属性?为什么 Vuex 的 mutation 中不能做异步操作?

有五种，分别是 State、 Getter、Mutation 、Action、 Module
1、state => 基本数据(数据源存放地)
2、getters => 从基本数据派生出来的数据
3、mutations => 提交更改数据的方法，同步
4、actions => 像一个装饰器，包裹mutations，使之可以异步。
5、modules => 模块化Vuex

1、Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。
2、每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。

#### Vue的生命周期是什么 每个钩子里面具体做了什么事情

Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -> 渲染、更新 -> 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。
1、beforeCreate（创建前） ：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event/watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。
2、created（创建后） ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 `$el` 属性。
3、beforeMount（挂载前） ：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。
4、mounted（挂载后） ：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。
5、beforeUpdate（更新前） ：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。
6、updated（更新后）：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。
7、beforeDestroy（销毁前） ：实例销毁之前调用。这一步，实例仍然完全可用，`this` 仍能获取到实例。
8、destroyed（销毁后） ：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。
另外还有 `keep-alive` 独有的生命周期，分别为 `activated` 和 `deactivated` 。用 `keep-alive` 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 `deactivated` 钩子函数，命中缓存渲染后会执行 `activated` 钩子函数。

#### 计算属性和watch有什么区别?以及它们的运用场景?

// 区别
  computed 计算属性：依赖其它属性值，并且computed的值有缓存，只有它依赖的属性值发生改变，下一次获取computed的值时才会重新计算computed的值。
  watch 侦听器：更多的是观察的作用,无缓存性,类似与某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作
//运用场景
  当需要进行数值计算,并且依赖与其它数据时,应该使用computed,因为可以利用computed的缓存属性,避免每次获取值时都要重新计算。
  当需要在数据变化时执行异步或开销较大的操作时,应该使用watch,使用watch选项允许执行异步操作（访问一个API),限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。

#### 说一下vue3.0你了解多少?

响应式原理的改变 Vue3.x 使用Proxy取代 Vue2.x 版本的Object.defineProperty** **

组件选项声明方式Vue3.x 使用Composition API setup 是Vue3.x新增的一个选项，他是组件内使用Composition API 的入口

模板语法变化slot具名插槽语法 自定义指令 v-model 升级

其它方面的更改Suspense支持Fragment(多个根节点) 和Protal (在dom其他部分渲染组建内容)组件

针对一些特殊的场景做了处理。基于**treeshaking**优化，提供了更多的内置功能。


### 简述MVVM

**MVVM**是 `Model-View-ViewModel`缩写，也就是把 `MVC`中的 `Controller`演变成 `ViewModel。Model`层代表数据模型，`View`代表UI组件，`ViewModel`是 `View`和 `Model`层的桥梁，数据会绑定到 `viewModel`层并自动将数据渲染到页面中，视图变化的时候会通知 `viewModel`层更新数据。

### 谈谈对vue生命周期的理解？

每个 `Vue`实例在创建时都会经过一系列的初始化过程，`vue`的生命周期钩子，就是说在达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件

* `create阶段`：vue实例被创建
  `beforeCreate`: 创建前，此时data和methods中的数据都还没有初始化
  `created`： 创建完毕，data中有值，未挂载
* `mount阶段`： vue实例被挂载到真实DOM节点
  `beforeMount`：可以发起服务端请求，去数据
  `mounted`: 此时可以操作Dom
* `update阶段`：当vue实例里面的data数据变化时，触发组件的重新渲染
  `beforeUpdate`
  `updated`
* `destroy阶段`：vue实例被销毁
  `beforeDestroy`：实例被销毁前，此时可以手动销毁一些方法
  `destroyed`

### `computed与watch`

**watch 属性监听**
是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作,监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用

**computed 计算属性**
属性的结果会被缓存，当 `computed`中的函数所依赖的属性没有发生改变的时候，那么调用当前函数的时候结果会从缓存中读取。除非依赖的响应式属性变化时才会重新计算，主要当做属性来使用
`computed`中的函数必须用 `return`返回最终的结果
`computed`更高效，优先使用

**使用场景**
`computed`：当一个属性受多个属性影响的时候使用，例：购物车商品结算功能
`watch`：当一条数据影响多条数据的时候使用，例：搜索数据

### v-for中key的作用

1. `key`的作用主要是为了更高效的对比虚拟DOM中每个节点是否是相同节点;
2. `Vue在patch`过程中判断两个节点是否是相同节点,key是一个必要条件，渲染一组列表时，key往往是唯一标识，所以如果不定义key的话，`Vue`只能认为比较的两个节点是同一个，哪怕它们实际上不是，这导致了频繁更新元素，使得整个 `patch`过程比较低效，影响性能;
3. 从源码中可以知道，Vue判断两个节点是否相同时主要判断两者的key和元素类型等，因此如果不设置key,它的值就是 `undefined`，则可能永    远认为这是两个相同的节点，只能去做更新操作，这造成了大量的dom更新操作，明显是不可取的。

### vue组件的通信方式

#### 父子组件通信

父->子 `props`，子->父 `$on、$emit` 获取父子组件实例 `parent、parent、**p**a**r**e**n**t**、**childrenRef `获取实例的方式调用组件的属性或者方法 `Provide、inject` 官方不推荐使用，但是写组件库时很常用

#### 兄弟组件通信

`Event Bus` 实现跨组件通信 `Vue.prototype.$bus = new Vue() Vuex`

#### 跨级组件通信

`$attrs、$listeners`
`Provide、inject`

### 常用指令

* v-if：判断是否隐藏；
* v-for：数据循环出来；
* v-bind:class：绑定一个属性；
* v-model：实现双向绑定

### 双向绑定实现原理

当一个**Vue**实例创建时，Vue会遍历data选项的属性，用 **Object.defineProperty** 将它们转为 getter/setter并且在内部追踪相关依赖，在属性被访问和修改时通知变化。每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher重新计算，从而致使它关联的组件得以更新。

### v-model的实现以及它的实现原理吗？

1. `vue`中双向绑定是一个指令 `v-model`，可以绑定一个动态值到视图，同时视图中变化能改变该值。`v-model`是语法糖，默认情况下相于:`value和@input`。
2. 使用 `v-model`可以减少大量繁琐的事件处理代码，提高开发效率，代码可读性也更好
3. 通常在表单项上使用 `v-model`
4. 原生的表单项可以直接使用 `v-model`，自定义组件上如果要使用它需要在组件内绑定value并处理输入事件
5. 我做过测试，输出包含 `v-model`模板的组件渲染函数，发现它会被转换为value属性的绑定以及一个事件监听，事件回调函数中会做相应变量更新操作，这说明神奇魔法实际上是vue的编译器完成的。

### nextTick的实现

1. `nextTick`是 `Vue`提供的一个全局 `API`,是在下次 `DOM`更新循环结束之后执行延迟回调，在修改数据之后使用 `$nextTick`，则可以在回调中获取更新后的 `DOM`；
2. Vue在更新DOM时是异步执行的。只要侦听到数据变化，`Vue`将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 `watcher`被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和 `DOM`操作是非常重要的。`nextTick`方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用；
3. 比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可；
4. 我也有简单了解 `nextTick`实现，它会在 `callbacks`里面加入我们传入的函数，然后用 `timerFunc`异步方式调用它们，首选的异步方式会是 `Promise`。这让我明白了为什么可以在 `nextTick`中看到 `dom`操作结果。

### vnode的理解，compiler和patch的过程

```javascript
vnode 虚拟DOM节点 创建：
export function Vnode (){
    return {
        tag:'div',
        children: 'span',
        attr:'',
        text:'你好!'
    }
}
复制代码
```

### new Vue后整个的流程

* `initProxy`：作用域代理，拦截组件内访问其它组件的数据。
* `initLifecycle`：建立父子组件关系，在当前组件实例上添加一些属性和生命周期标识。如 `[Math Processing Error]parent,parent,refs,$children,_isMounted`等。
* `initEvents`：对父组件传入的事件添加监听，事件是谁创建谁监听，子组件创建事件子组件监听
* `initRender`：声明[Math Processing Error]slots和slots和createElement()等。
* `initInjections`：注入数据，初始化inject，一般用于组件更深层次之间的通信。
* `initState`：重要）数据响应式：初始化状态。很多选项初始化的汇总：data,methods,props,computed和watch。
* `initProvide`：提供数据注入。
  **思考：为什么先注入再提供呢？？**

答：1、首先来自祖辈的数据要和当前实例的data,等判重，相结合，所以注入数据的initInjections一定要在 `InitState`的上面。2. 从上面注入进来的东西在当前组件中转了一下又提供给后代了，所以注入数据也一定要在上面。

`vm.[Math Processing Error]mount(vm.mount(vm.options.el)`：挂载实例。

### keep-alive的实现

作用：实现组件缓存

#### 钩子函数：

```go
`activated `组件渲染后调用
`deactivated `组件销毁后调用
复制代码
```

原理：`Vue.js`内部将 `DOM`节点抽象成了一个个的 `VNode`节点，`keep-alive`组件的缓存也是基于 `VNode`节点的而不是直接存储 `DOM`结构。它将满足条件 `（pruneCache与pruneCache）`的组件在 `cache`对象中缓存起来，在需要重新渲染的时候再将 `vnode`节点从 `cache`对象中取出并渲染。

#### 配置属性：

`include` 字符串或正则表达式。只有名称匹配的组件会被缓存

`exclude` 字符串或正则表达式。任何名称匹配的组件都不会被缓存

`max` 数字、最多可以缓存多少组件实例

### vuex、vue-router实现原理

`vuex`是一个专门为vue.js应用程序开发的状态管理库。
核心概念：

* `state`(单一状态树) `getter/Mutation`显示提交更改 `state`
* `Action类似Mutation`，提交 `Mutation`，可以包含任意异步操作。
* `module`(当应用变得庞大复杂，拆分 `store`为具体的 `module`模块)

### 你怎么理解Vue中的diff算法?

在js中,渲染真实 `DOM`的开销是非常大的, 比如我们修改了某个数据,如果直接渲染到真实 `DOM`, 会引起整个 `dom`树的重绘和重排。那么有没有可能实现只更新我们修改的那一小块dom而不要更新整个 `dom`呢？此时我们就需要先根据真实 `dom`生成虚拟 `dom`， 当虚拟 `dom`某个节点的数据改变后会生成有一个新的 `Vnode`, 然后新的 `Vnode`和旧的 `Vnode`作比较，发现有不一样的地方就直接修改在真实DOM上，然后使旧的 `Vnode`的值为新的 `Vnode`。

**diff**的过程就是调用 `patch`函数，比较新旧节点，一边比较一边给真实的 `DOM`打补丁。在采取 `diff`算法比较新旧节点的时候，比较只会在同层级进行。
在 `patch`方法中，首先进行树级别的比较
`new Vnode`不存在就删除 `old Vnode`
`old Vnode` 不存在就增加新的 `Vnode`
都存在就执行diff更新
当确定需要执行diff算法时，比较两个 `Vnode`，包括三种类型操作：属性更新，文本更新，子节点更新
新老节点均有子节点，则对子节点进行 `diff`操作，调用 `updatechidren`
如果老节点没有子节点而新节点有子节点，先清空老节点的文本内容，然后为其新增子节点
如果新节点没有子节点，而老节点有子节点的时候，则移除该节点的所有子节点
老新老节点都没有子节点的时候，进行文本的替换

**updateChildren**
将 `Vnode`的子节点Vch和oldVnode的子节点oldCh提取出来。
`oldCh和vCh`各有两个头尾的变量 `StartIdx和EndIdx`，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了 `key`，就会用 `key`进行比较，在比较的过程中，变量会往中间靠，一旦 `StartIdx>EndIdx`表明 `oldCh和vCh`至少有一个已经遍历完了，就会结束比较。

### 你都做过哪些Vue的性能优化？

```javascript
编码阶段
尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
v-if和v-for不能连用
如果需要使用v-for给每项元素绑定事件时使用事件代理
SPA 页面采用keep-alive缓存组件
在更多的情况下，使用v-if替代v-show
key保证唯一
使用路由懒加载、异步组件
防抖、节流
第三方模块按需导入
长列表滚动到可视区域动态加载
图片懒加载
SEO优化
预渲染
服务端渲染SSR
打包优化
压缩代码
Tree Shaking/Scope Hoisting
使用cdn加载第三方模块
多线程打包happypack
splitChunks抽离公共文件
sourceMap优化
用户体验
骨架屏
PWA
还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。
复制代码
```

### 你知道Vue3有哪些新特性吗？它们会带来什么影响？

* **性能提升**
  更小巧、更快速
  支持自定义渲染器
  支持摇树优化：一种在打包时去除无用代码的优化手段
  支持Fragments和跨组件渲染
* **API变动**
  模板语法99%保持不变
  原生支持基于class的组件，并且无需借助任何编译及各种stage阶段的特性
  在设计时也考虑TypeScript的类型推断特性
  `重写虚拟DOM`可以期待更多的编译时提示来减少运行时的开销
  `优化插槽生成`可以单独渲染父组件和子组件
  `静态树提升`降低渲染成本
  `基于Proxy的观察者机制`节省内存开销
* **不兼容IE11**
  `检测机制`更加全面、精准、高效,更具可调试式的响应跟踪

### 实现双向绑定 Proxy 与 Object.defineProperty 相比优劣如何?

1. **Object.definedProperty**的作用是劫持一个对象的属性，劫持属性的getter和setter方法，在对象的属性发生变化时进行特定的操作。而   Proxy劫持的是整个对象。
2. **Proxy**会返回一个代理对象，我们只需要操作新对象即可，而Object.defineProperty只能遍历对象属性直接修改。
3. **Object.definedProperty**不支持数组，更准确的说是不支持数组的各种API，因为如果仅仅考虑arry[i] = value 这种情况，是可以劫持   的，但是这种劫持意义不大。而Proxy可以支持数组的各种API。
4. 尽管Object.defineProperty有诸多缺陷，但是其兼容性要好于Proxy。





### 什么是 HTML DOM？

`HTML DOM` 是 `HTML `的标准*对象*模型和 *编程接口* 。它定义了：

* 作为*对象*的 `HTML` 元素
* 所有 ` HTML` 元素的*属性*
* 访问所有 `HTML`元素的*方法*
* 所有 `HTML` 元素的*事件*

 **换言之：`HTML DOM` 是关于如何获取、更改、添加或删除 HTML 元素的标准** 。

### 虚拟Dom是什么？

`virtual DOM` 虚拟 `DOM`，用普通 `js`对象来描述 `DOM`结构，它通过 `JS`的 `Object`对象模拟 `DOM`中的节点，然后再通过特定的 `render`方法将其渲染成真实的 `DOM`节点。因为不是真实 `DOM`，所以称之为虚拟 `DOM`。

**总结来说一句话：`virtual DOM`就是 `Dom`的抽象化**

### 为什么操作真实DOM的成本比较高？

(1)`dom`树的实现模块和 `js `模块是分开的这些跨模块的通讯增加了成本

(2) `dom `操作引起的浏览器的回流和重绘，使得性能开销巨大。

原本在 `pc `端是没有性能问题的，因为pc端的计算能力强，但是随着移动端的发展，越来越多的网页在智能手机上运行，而手机的性能参差不齐，会有性能问题。
我们之前用 `jquery`在 `pc`端写那些商城页面都没有问题，但放到移动端浏览器访问之后会发现除了首页会出现白屏之外在其他页面的操作并不流畅。

### 为何虚拟Dom性能更优？

虚拟 `dom `是相对于浏览器所渲染出来的真实 `dom`而言的，在 `react`，`vue`等技术出现之前，我们要改变页面展示的内容只能通过遍历查询 `dom `树的方式找到需要修改的 dom 然后修改样式行为或者结构，来达到更新 `ui `的目的。

这种方式相当消耗计算资源，因为每次查询 `dom` 几乎都需要遍历整颗 `dom `树，如果建立一个与 `dom` 树对应的虚拟 `dom `对象（ `js` 对象），以对象嵌套的方式来表示 `dom`树及其层级结构，那么每次 `dom` 的更改就变成了对 `js` 对象的属性的增删改查，这样一来查找 js 对象的属性变化要比查询 `dom `树的性能开销小。

### Vue如何实现虚拟DOM的？（详解）

首先可以看看 `vue`中 `VNode`的结构

**vnode.js**

```js
export default class VNode {
  tag: string | void;
  data: VNodeData | void;
  children: ?Array<VNode>;
  text: string | void;
  elm: Node | void;
  ns: string | void;
  context: Component | void; // rendered in this component's scope
  functionalContext: Component | void; // only for functional component root nodes
  key: string | number | void;
  componentOptions: VNodeComponentOptions | void;
  componentInstance: Component | void; // component instance
  parent: VNode | void; // component placeholder node
  raw: boolean; // contains raw HTML? (server only)
  isStatic: boolean; // hoisted static node
  isRootInsert: boolean; // necessary for enter transition check
  isComment: boolean; // empty comment placeholder?
  isCloned: boolean; // is a cloned node?
  isOnce: boolean; // is a v-once node?

  constructor (
    tag?: string,
    data?: VNodeData,
    children?: ?Array<VNode>,
    text?: string,
    elm?: Node,
    context?: Component,
    componentOptions?: VNodeComponentOptions
  ) {
    /*当前节点的标签名*/
    this.tag = tag
    /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/
    this.data = data
    /*当前节点的子节点，是一个数组*/
    this.children = children
    /*当前节点的文本*/
    this.text = text
    /*当前虚拟节点对应的真实dom节点*/
    this.elm = elm
    /*当前节点的名字空间*/
    this.ns = undefined
    /*编译作用域*/
    this.context = context
    /*函数化组件作用域*/
    this.functionalContext = undefined
    /*节点的key属性，被当作节点的标志，用以优化*/
    this.key = data && data.key
    /*组件的option选项*/
    this.componentOptions = componentOptions
    /*当前节点对应的组件的实例*/
    this.componentInstance = undefined
    /*当前节点的父节点*/
    this.parent = undefined
    /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/
    this.raw = false
    /*静态节点标志*/
    this.isStatic = false
    /*是否作为跟节点插入*/
    this.isRootInsert = true
    /*是否为注释节点*/
    this.isComment = false
    /*是否为克隆节点*/
    this.isCloned = false
    /*是否有v-once指令*/
    this.isOnce = false
  }

  // DEPRECATED: alias for componentInstance for backwards compat.
  /* istanbul ignore next https://github.com/answershuto/learnVue*/
  get child (): Component | void {
    return this.componentInstance
  }
}
复制代码
```

这里对 `VNode`进行稍微的说明：

* 所有对象的 `context` 选项都指向了 ` Vue` 实例
* `elm `属性则指向了其相对应的真实 ` DOM` 节点

  `vue`是通过 `createElement`生成 `VNode`
  再看看源码 `create-element.js`

```js
export function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  return _createElement(context, tag, data, children, normalizationType)
}

复制代码
```

上面可以看到 `createElement` 方法实际上是对 `_createElement `方法的封装，对参数的传入进行了判断

```js
export function _createElement(
    context: Component,
    tag?: string | Class<Component> | Function | Object,
    data?: VNodeData,
    children?: any,
    normalizationType?: number
): VNode | Array<VNode> {
    if (isDef(data) && isDef((data: any).__ob__)) {
        process.env.NODE_ENV !== 'production' && warn(
            `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
            'Always create fresh vnode data objects in each render!',
            context`
        )
        return createEmptyVNode()
    }
    // object syntax in v-bind
    if (isDef(data) && isDef(data.is)) {
        tag = data.is
    }
    if (!tag) {
        // in case of component :is set to falsy value
        return createEmptyVNode()
    }
    ... 
    // support single function children as default scoped slot
    if (Array.isArray(children) &&
        typeof children[0] === 'function'
    ) {
        data = data || {}
        data.scopedSlots = { default: children[0] }
        children.length = 0
    }
    if (normalizationType === ALWAYS_NORMALIZE) {
        children = normalizeChildren(children)
    } else if ( === SIMPLE_NORMALIZE) {
        children = simpleNormalizeChildren(children)
    }
 // 创建VNode
    ...
}
复制代码
```

可以看到 `_createElement`接收5个参数：

`context` 表示 `VNode` 的上下文环境，是 `Component`类型

`tag `表示标签，它可以是一个字符串，也可以是一个 `Component`

`data` 表示 `VNode `的数据，它是一个 `VNodeData` 类型

`children` 表示当前 `VNode`的子节点，它是任意类型的

`normalizationType `表示子节点规范的类型，类型不同规范的方法也就不一样，主要是参考 `render `函数是编译生成的还是用户手写的

根据 `normalizationType `的类型，`children`会有不同的定义

```js
if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
} else if ( === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
}
复制代码
```

`simpleNormalizeChildren`方法调用场景是 `render`函数是编译生成的

`normalizeChildren`方法调用场景分为下面两种：

`render `函数是用户手写的
编译 `slot、v-for` 的时候会产生嵌套数组
无论是 `simpleNormalizeChildren`还是 `normalizeChildren`都是对 `children`进行规范（使 `children` 变成了一个类型为 `VNode` 的 `Array`），这里就不展开说了

规范化 `children`的源码位置在：`src/core/vdom/helpers/normalzie-children.js`

在规范化 `children`后，就去创建 `VNode`

```js
let vnode, ns
// 对tag进行判断
if (typeof tag === 'string') {
  let Ctor
  ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
  if (config.isReservedTag(tag)) {
    // 如果是内置的节点，则直接创建一个普通VNode
    vnode = new VNode(
      config.parsePlatformTagName(tag), data, children,
      undefined, undefined, context
    )
  } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
    // component
    // 如果是component类型，则会通过createComponent创建VNode节点
    vnode = createComponent(Ctor, data, context, children, tag)
  } else {
    vnode = new VNode(
      tag, data, children,
      undefined, undefined, context
    )
  }
} else {
  // direct component options / constructor
  vnode = createComponent(tag, data, context, children)
}
复制代码
```

稍微提下 `createComponent`生成 `VNode`的三个关键流程：

* 构造子类构造函数 `Ctor`
* `installComponentHooks`安装组件钩子函数
* 实例化 `vnode`

### 小结

**`createElement` 创建 VNode 的过程，每个 `VNode` 有 `children`，`children`每个元素也是一个 `VNode`，这样就形成了一个虚拟树结构，用于描述真实的 `DOM`树结构**



等vue2源码学习后，再来看着几个面试题：

https://juejin.cn/post/6919373017218809864

https://juejin.cn/post/6964779204462247950/
