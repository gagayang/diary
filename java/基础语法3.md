# Collection:

![1692752692291](image/基础语法3/1692752692291.png)

## set 和list 简单对比

```java
// 有序 可重复 有索引
Collection list = new ArrayList();
list.add("Java");
list.add("Java");
list.add("Mybatis");
list.add(23);
list.add(23);
list.add(false);
list.add(false);
System.out.println(list); // [Java, Java, Mybatis, 23, 23, false, false]

// 无序 不重复  无索引 但是每次打印出来的顺序是固定的（奇怪）
Collection list1 = new HashSet();
list1.add("Java");
list1.add("Java");
list1.add("Mybatis");
list1.add(23);
list1.add(23);
list1.add(false);
list1.add(false);
System.out.println(list1); // [Java, false, 23, Mybatis]
```

## ArrayList操作：

![1692752719981](image/基础语法3/1692752719981.png)

### 增删改查：

```java
package com.itheima.d2_collection_api;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;

/**
 目标：Collection集合的常用API.
 Collection是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。
 Collection API如下:
 - public boolean add(E e)：  把给定的对象添加到当前集合中 。
 - public void clear() :清空集合中所有的元素。
 - public boolean remove(E e): 把给定的对象在当前集合中删除。
 - public boolean contains(Object obj): 判断当前集合中是否包含给定的对象。
 - public boolean isEmpty(): 判断当前集合是否为空。
 - public int size(): 返回集合中元素的个数。
 - public Object[] toArray(): 把集合中的元素，存储到数组中。
 小结：
 记住以上API。
 */
public class Haha {
  public static void main(String[] args) {
    // HashSet:添加的元素是无序，不重复，无索引。
    Collection<String> c = new ArrayList<>();
    // 1.添加元素, 添加成功返回true。
    c.add("Java");
    c.add("HTML");
    System.out.println(c.add("HTML")); // true
    c.add("MySQL");
    c.add("Java");
    System.out.println(c.add("黑马")); // true
    System.out.println(c); // [Java, HTML, HTML, MySQL, Java, 黑马]

    // 2.清空集合的元素。
    // c.clear();
    // System.out.println(c);

    // 3.判断集合是否为空 是空返回true,反之。
    System.out.println(c.isEmpty());

    // 4.获取集合的大小。
    System.out.println(c.size());

    // 5.判断集合中是否包含某个元素。
    System.out.println(c.contains("Java"));  // true
    System.out.println(c.contains("java")); // false
    System.out.println(c.contains("黑马")); // true

    // 6.删除某个元素:如果有多个重复元素默认删除前面的第一个！
    System.out.println(c.remove("java")); // false (大小写不匹配)
    System.out.println("=====");
    System.out.println(c); // [Java, HTML, HTML, MySQL, Java, 黑马]
    System.out.println(c.remove("Java")); // true (只删除匹配上的第一个)
    System.out.println(c); // [HTML, HTML, MySQL, Java, 黑马]

    // 7.把集合转换成数组  [HTML, HTML, MySQL, Java, 黑马]
    Object[] arrs = c.toArray();
    System.out.println("数组：" + Arrays.toString(arrs));

    System.out.println("----------------------拓展----------------------");
    Collection<String> c1 = new ArrayList<>();
    c1.add("java1");
    c1.add("java2");
    Collection<String> c2 = new ArrayList<>();
    c2.add("赵敏");
    c2.add("殷素素");
    // addAll把c2集合的元素全部倒入到c1中去。
    c1.addAll(c2); 
    System.out.println(c1);// [java1, java2, 赵敏, 殷素素]
    System.out.println(c2); // [赵敏, 殷素素]
  }
}

```

### 遍历：

#### iterator：

```java
package com.itheima.d3_collection_traversal;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

/**
    目标：Collection集合的遍历方式。

    什么是遍历? 为什么开发中要遍历？
        遍历就是一个一个的把容器中的元素访问一遍。
        开发中经常要统计元素的总和，找最值，找出某个数据然后干掉等等业务都需要遍历。

    Collection集合的遍历方式是全部集合都可以直接使用的，所以我们学习它。
    Collection集合的遍历方式有三种:
        （1）迭代器。
        （2）foreach(增强for循环)。
        （3）JDK 1.8开始之后的新技术Lambda表达式(了解)

    a.迭代器遍历集合。
        -- 方法：
             public Iterator iterator(): 获取集合对应的迭代器，用来遍历集合中的元素的
             boolean hasNext():判断是否有下一个元素，有返回true ,反之。
             E next():获取下一个元素值！
        --流程：
            1.先获取当前集合的迭代器
                Iterator<String> it = lists.iterator();
            2.定义一个while循环，问一次取一次。
              通过it.hasNext()询问是否有下一个元素，有就通过
              it.next()取出下一个元素。
    小结：
        记住代码。
 */
public class CollectionDemo01 {
    public static void main(String[] args) {
        ArrayList<String> lists = new ArrayList<>();
        lists.add("赵敏");
        lists.add("小昭");
        lists.add("素素");
        lists.add("灭绝");
        System.out.println(lists);
        // [赵敏, 小昭, 素素, 灭绝]
        //   it

        // 1、得到当前集合的迭代器对象。
        Iterator<String> it = lists.iterator();
//        String ele = it.next();
//        System.out.println(ele);
//        System.out.println(it.next());
//        System.out.println(it.next());
//        System.out.println(it.next());
        // System.out.println(it.next()); // NoSuchElementException 出现无此元素异常的错误

        // 2、定义while循环
        while (it.hasNext()){
            String ele = it.next();
            System.out.println(ele);
        }
        System.out.println("-----------------------------");

    }
}

```

#### 增强for：

```java
package com.itheima.d3_collection_traversal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
/**
     目标：Collection集合的遍历方式。

     什么是遍历? 为什么开发中要遍历？
     遍历就是一个一个的把容器中的元素访问一遍。
     开发中经常要统计元素的总和，找最值，找出某个数据然后干掉等等业务都需要遍历。

     Collection集合的遍历方式是全部集合都可以直接使用的，所以我们学习它。
     Collection集合的遍历方式有三种:
         （1）迭代器。
         （2）foreach(增强for循环)。
         （3）JDK 1.8开始之后的新技术Lambda表达式。

     b.foreach(增强for循环)遍历集合。
         foreach是一种遍历形式，可以遍历集合或者数组。
         foreach遍历集合实际上是迭代器遍历集合的简化写法。
         foreach遍历的关键是记住格式：
            for(被遍历集合或者数组中元素的类型 变量名称 : 被遍历集合或者数组){

            }
 */
public class CollectionDemo02 {
    public static void main(String[] args) {
        Collection<String> lists = new ArrayList<>();
        lists.add("赵敏");
        lists.add("小昭");
        lists.add("殷素素");
        lists.add("周芷若");
        System.out.println(lists);
        // [赵敏, 小昭, 殷素素, 周芷若]
        //  ele

        for (String ele : lists) {
            System.out.println(ele);
        }

        System.out.println("------------------");
        double[] scores = {100, 99.5 , 59.5};
        for (double score : scores) {
            System.out.println(score);
//            if(score == 59.5){
//                score = 100.0; // 修改无意义，不会影响数组的元素值。
//            }
        }
        System.out.println(Arrays.toString(scores));

    }
}

```

#### forEach（lambda):

```java
package com.itheima.d3_collection_traversal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.function.Consumer;

/**
 目标：Collection集合的遍历方式。

 什么是遍历? 为什么开发中要遍历？
 遍历就是一个一个的把容器中的元素访问一遍。
 开发中经常要统计元素的总和，找最值，找出某个数据然后干掉等等业务都需要遍历。

 Collection集合的遍历方式是全部集合都可以直接使用的，所以我们学习它。
 Collection集合的遍历方式有三种:
 （1）迭代器。
 （2）foreach(增强for循环)。
 （3）JDK 1.8开始之后的新技术Lambda表达式。
 c.JDK 1.8开始之后的新技术Lambda表达式。
 */
public class Haha {
  public static void main(String[] args) {
    Collection<String> lists = new ArrayList<>();
    lists.add("赵敏");
    lists.add("小昭");
    lists.add("殷素素");
    lists.add("周芷若");
    System.out.println(lists);
    // [赵敏, 小昭, 殷素素, 周芷若]
    //  s
    lists.forEach(new Consumer<String>() {
      @Override
      public void accept(String s) {
        System.out.println(s);
      }
    });
    System.out.println("------------------");

    lists.forEach(s -> {
      System.out.println(s);
    });
    System.out.println("------------------");

    lists.forEach(s ->  System.out.println(s) );
    System.out.println("------------------");

    lists.forEach(System.out::println );

  }
}

```

综上，目前遍历集合的方式有四种：

```java
package com.itheima.d5_collection_list;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
    拓展：List系列集合的遍历方式有：4种。

    List系列集合多了索引，所以多了一种按照索引遍历集合的for循环。

    List遍历方式：
        （1）for循环。(独有的，因为List有索引)。
        （2）迭代器。
        （3）foreach。
        （4）JDK 1.8新技术。
 */
public class ListDemo02 {
    public static void main(String[] args) {
        List<String> lists = new ArrayList<>();
        lists.add("java1");
        lists.add("java2");
        lists.add("java3");

        /** （1）for循环。 */
        System.out.println("-----------------------");

        for (int i = 0; i < lists.size(); i++) {
            String ele = lists.get(i);
            System.out.println(ele);
        }


        /** （2）迭代器。 */
        System.out.println("-----------------------");
        Iterator<String> it = lists.iterator();
        while (it.hasNext()){
            String ele = it.next();
            System.out.println(ele);
        }

        /** （3）foreach */
        System.out.println("-----------------------");
        for (String ele : lists) {
            System.out.println(ele);
        }

        /** （4）JDK 1.8开始之后的Lambda表达式  */
        System.out.println("-----------------------");
        lists.forEach(s -> {
            System.out.println(s);
        });

    }
}

```

这四种遍历，有一种场合是一遍遍历，一边删除集合内的数据，这个场合只有iterator 和 for（从大到小的遍历)可以做到：

```java
package com.itheima.d6_collection_update_delete;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

/**
    目标：研究集合遍历并删除元素可能出现的：并发修改异常问题。
 */
public class Test {
    public static void main(String[] args) {
        // 1、准备数据
        ArrayList<String> list = new ArrayList<>();
        list.add("黑马");
        list.add("Java");
        list.add("Java");
        list.add("赵敏");
        list.add("赵敏");
        list.add("素素");
        System.out.println(list);
        // [黑马, Java, Java, 赵敏, 赵敏, 素素]
        //        it

        // 需求：删除全部的Java信息。
        // a、迭代器遍历删除
        Iterator<String> it = list.iterator();
//        while (it.hasNext()){
//            String ele = it.next();
//            if("Java".equals(ele)){
//                // 删除Java
//                // list.remove(ele); // 集合删除会出毛病
//                it.remove(); // 删除迭代器所在位置的元素值（没毛病）
//            }
//        }
//        System.out.println(list);

        // b、foreach遍历删除 (会出现问题，这种无法解决的，foreach不能边遍历边删除，会出bug)
//        for (String s : list) {
//            if("Java".equals(s)){
//                list.remove(s);
//            }
//        }

        // c、lambda表达式(会出现问题，这种无法解决的，Lambda遍历不能边遍历边删除，会出bug)
//        list.forEach(s -> {
//            if("Java".equals(s)){
//                list.remove(s);
//            }
//        });

        // d、for循环(边遍历边删除集合没毛病，但是必须从后面开始遍历删除才不会出现漏掉应该删除的元素)
        for (int i = list.size() - 1; i >= 0 ; i--) {
            String ele = list.get(i);
            if("Java".equals(ele)){
                list.remove(ele);
            }
        }
        System.out.println(list);
    }
}

```

### 多态：

![1692752741996](image/基础语法3/1692752741996.png)

注意上面这种是多态的写法，多态下的集合是不能使用ArrayList下的特有方法的，比如list3.get(1) (获取某个位置下的元素)，下面的写法不是多态就可以：

```java
package com.itheima.d5_collection_list;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedList;
import java.util.List;

/**
      目标：ArrayList集合。

      Collection集合的体系
                         Collection<E>(接口)
              /                                                \
           Set<E>(接口)                                         List<E>(接口)
            /                  \                               /                     \                  \
          HashSet<E>(实现类)    TreeSet<E>(实现类)          LinkedList<E>(实现类)  Vector(线程安全)     ArrayList<E>(实现类)
          /
         LinkedHashSet<E>(实现类)

      Collection集合体系的特点:
         Set系列集合： 添加的元素，是无序，不重复，无索引的。
             -- HashSet：添加的元素，是无序，不重复，无索引的。
             -- LinkedHashSet：添加的元素，是有序，不重复，无索引的。
         List系列集合：添加的元素，是有序，可重复，有索引的。
             -- LinkedList： 添加的元素，是有序，可重复，有索引的。
             -- ArrayList： 添加的元素，是有序，可重复，有索引的。
             -- Vector 是线程安全的，速度慢，工作中很少使用。

         1、List集合继承了Collection集合的全部功能，"同时因为List系列集合有索引"，
         2、因为List集合多了索引，所以多了很多按照索引操作元素的功能: （多态不能用这些独有方法）
         3、ArrayList实现类集合底层基于数组存储数据的，查询快，增删慢！
             - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。
             - public E get(int index):返回集合中指定位置的元素。
             - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。
             - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回更新前的元素值。
      小结：
            ArrayList集合的底层是基于数组存储数据。查询快，增删慢！（相对的）
 */
public class ListDemo01 {
    public static void main(String[] args) {
        // 1.创建一个ArrayList集合对象：
        // List:有序，可重复，有索引的。
        ArrayList<String> list = new ArrayList<>(); // 一行经典代码！1.7开始之后后面的泛型申明可以省略不写
        list.add("Java");
        list.add("Java");
        list.add("HTML");
        list.add("HTML");
        list.add("MySQL");
        list.add("MySQL");

        // 2.在某个索引位置插入元素。
        list.add(2, "黑马");
        System.out.println(list);

        // 3.根据索引删除元素,返回被删除元素
        System.out.println(list.remove(1));
        System.out.println(list);

        // 4.根据索引获取元素:public E get(int index):返回集合中指定位置的元素。
        System.out.println(list.get(1));

        // 5.修改索引位置处的元素: public E set(int index, E element)
        System.out.println(list.set(1, "传智教育"));
        System.out.println(list);
    }
}

```

### 泛型：

主要是泛型类，泛型方法，泛型接口

![1692752946399](image/基础语法3/1692752946399.png)

![1692752967814](image/基础语法3/1692752967814.png)

集合和泛型不支持基本数据类型，只能支持引用数据类型:

```java
// Collection<int> list3 = new ArrayList<>(); 报错
Collection<Integer> list3 = new ArrayList<>();
list3.add(23);
list3.add(233);
list3.add(2333);

Collection<Double> list4 = new ArrayList<>();
list4.add(23.4);
list4.add(233.0);
list4.add(233.3);
```

demo：

```java
package com.itheima.d9_genericity_method;

/**
    目标：自定义泛型方法。

    什么是泛型方法？
        定义了泛型的方法就是泛型方法。

    泛型方法的定义格式:
        修饰符 <泛型变量> 返回值类型 方法名称(形参列表){

        }
        注意：方法定义了是什么泛型变量，后面就只能用什么泛型变量。
        泛型类的核心思想：是把出现泛型变量的地方全部替换成传输的真实数据类型。

    需求：给你任何一个类型的数组，都能返回它的内容。Arrays.toString(数组)的功能！

    小结：
        泛型方法可以让方法更灵活的接收数据，可以做通用技术！
 */
public class GenericDemo {
    public static void main(String[] args) {
        String[] names = {"小璐", "蓉容", "小何"};
        printArray(names);

        Integer[] ages = {10, 20, 30};
        printArray(ages);

        Integer[] ages2 = getArr(ages);
        String[]  names2 = getArr(names);
    }

    public static <T> T[] getArr(T[] arr){
        return arr;
    }

    public static <T> void printArray(T[] arr){
        if(arr != null){
            StringBuilder sb = new StringBuilder("[");
            for (int i = 0; i < arr.length; i++) {
                sb.append(arr[i]).append(i == arr.length - 1 ? "" : ", ");
            }
            sb.append("]");
            System.out.println(sb);
        }else {
            System.out.println(arr);
        }
    }
}

```

#### 泛型类：

demo：

![1692753035916](image/基础语法3/1692753035916.png)

#### 泛型接口：

```
泛型接口的格式：
 修饰符 interface 接口名称<泛型变量>{

 }
```

demo: 同级目录三个文件：

```java
package com.itheima.d10_genericity_interface;

public interface Data<E> {
    void add(E e);
    void delete(int id);
    void update(E e);
    E queryById(int id);
}

```

```java
package com.itheima.d10_genericity_interface;

public class Student {
}

```

```java
package com.itheima.d10_genericity_interface;

public class StudentData implements Data<Student>{
    @Override
    public void add(Student student) {

    }

    @Override
    public void delete(int id) {

    }

    @Override
    public void update(Student student) {

    }

    @Override
    public Student queryById(int id) {
        return null;
    }
}


```

#### 泛型通配符?

![1692753080176](image/基础语法3/1692753080176.png)

这个语法其实和js中的extends约束泛型可以理解成一回事，比如下面的demo，当我们想在go方法中传递集合，但是这个集合的实际类型是Car类型，但是我们又不能将形参约束为ArrayList < Car >, 因为Car和BMW，BENZ的继承关系，和函数传递的ArrayList< XX  > 是没有必然关系的，也就是，虽然BMW和BENZ都继承了Car，但是ArrayList `<BMW>`和ArrayList `<BENZ>`与ArrayList `<Car>`没有关系的！!

demo:

```java
package com.itheima.d11_genericity_limit;

import java.util.ArrayList;

/**
    目标：泛型通配符。?

    需求：开发一个极品飞车的游戏，所有的汽车都能一起参与比赛。

    注意：
        虽然BMW和BENZ都继承了Car
        但是ArrayList<BMW>和ArrayList<BENZ>与ArrayList<Car>没有关系的！!
    通配符：？
        ？可以在“使用泛型”的时候代表一切类型。
        E T K V 是在定义泛型的时候使用的。
    泛型的上下限：
        ？ extends Car : ?必须是Car或者其子类  泛型上限
        ? super Car ：？必须是Car或者其父类   泛型下限
    小结：
        通配符：？
        ？可以在“使用泛型”的时候代表一切类型。

 */
public class GenericDemo {
    public static void main(String[] args) {
        ArrayList<BMW> bmws = new ArrayList<>();
        bmws.add(new BMW());
        bmws.add(new BMW());
        bmws.add(new BMW());
        go(bmws);

        ArrayList<BENZ> benzs = new ArrayList<>();
        benzs.add(new BENZ());
        benzs.add(new BENZ());
        benzs.add(new BENZ());
        go(benzs);

        ArrayList<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog());
        dogs.add(new Dog());
        dogs.add(new Dog());
        // go(dogs);
    }

    /**
       所有车比赛
     */
    public static void go(ArrayList<? extends Car> cars){
    }
}

class Dog{

}

class BENZ extends Car{
}

class BMW extends Car{
}

// 父类
class Car{
}



```

好处就是约束了只能传递车的集合，狗就不能传递了

## LinkedList:

![1692752760912](image/基础语法3/1692752760912.png)

```java
package com.itheima.d5_collection_list;

import java.util.LinkedList;
import java.util.List;

/**
     目标：LinkedList集合。

     Collection集合的体系:
                Collection<E>(接口)
     /                                       \
     Set<E>(接口)                             List<E>(接口)
     /                                   /                    \               \
     HashSet<E>(实现类)                   LinkedList<E>(实现类) Vector(实现类)  ArrayList<E>(实现类)
     /
     LinkedHashSet<E>(实现类)

     Collection集合体系的特点:
         Set系列集合： 添加的元素，是无序，不重复，无索引的。
             -- HashSet：添加的元素，是无序，不重复，无索引的。
             -- LinkedHashSet：添加的元素，是有序，不重复，无索引的。
         List系列集合：添加的元素，是有序，可重复，有索引的。
             -- LinkedList： 添加的元素，是有序，可重复，有索引的。
             -- Vector： 添加的元素，是有序，可重复，有索引的。线程安全（淘汰了）
             -- ArrayList： 添加的元素，是有序，可重复，有索引的。

     LinkedList也是List的实现类：底层是基于双链表的，增删比较快，查询慢！！
     LinkedList是支持双链表，定位前后的元素是非常快的，增删首尾的元素也是最快的
     所以LinkedList除了拥有List集合的全部功能还多了很多操作首尾元素的特殊功能：
         - public void addFirst(E e):将指定元素插入此列表的开头。
         - public void addLast(E e):将指定元素添加到此列表的结尾。
         - public E getFirst():返回此列表的第一个元素。
         - public E getLast():返回此列表的最后一个元素。
         - public E removeFirst():移除并返回此列表的第一个元素。
         - public E removeLast():移除并返回此列表的最后一个元素。
         - public E pop():从此列表所表示的堆栈处弹出一个元素。
         - public void push(E e):将元素推入此列表所表示的堆栈。

    小结：
         LinkedList是支持双链表，定位前后的元素是非常快的，增删首尾的元素也是最快的。
         所以提供了很多操作首尾元素的特殊API可的实以做栈和队列现。

         如果查询多而增删少用ArrayList集合。(用的最多的)
         如果查询少而增删首尾较多用LinkedList集合。
 */
public class ListDemo03 {
    public static void main(String[] args) {
        // LinkedList可以完成队列结构，和栈结构 （双链表）
        // 1、做一个队列：
        LinkedList<String> queue = new LinkedList<>();
        // 入队
        queue.addLast("1号");
        queue.addLast("2号");
        queue.addLast("3号");
        System.out.println(queue);
        // 出队
        // System.out.println(queue.getFirst());
        System.out.println(queue.removeFirst());
        System.out.println(queue.removeFirst());
        System.out.println(queue);

        // 2、做一个栈
        LinkedList<String> stack = new LinkedList<>();
        // 入栈 压栈 (push)
        stack.push("第1颗子弹"); // push 其实就是addFirst，它只是一种优雅的写法
        stack.push("第2颗子弹");
        stack.push("第3颗子弹");
        stack.push("第4颗子弹");
        System.out.println(stack);

        // 出栈  弹栈 pop
        System.out.println(stack.pop()); // pop 其实就是removeFirst，它只是一种优雅的写法
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack);

    }
}















```

# 数据结构：

## 栈：

![1692753119228](image/基础语法3/1692753119228.png)

## 队列：

![1692753158489](image/基础语法3/1692753158489.png)

## 数组：

![1692753187975](image/基础语法3/1692753187975.png)

## 链表：

![1692753244177](image/基础语法3/1692753244177.png)

![1692753259542](image/基础语法3/1692753259542.png)

## 二叉树：

![1692753297509](image/基础语法3/1692753297509.png)

![1692753323739](image/基础语法3/1692753323739.png)

二叉树存在的问题：

二分查找优势是增删改查都较好，但是如截图，极端情况就变成了一个链表，所以出现了平衡二叉树

![1692752637714](image/基础语法3/1692752637714.png)

平衡二叉树：

![1692753349521](image/基础语法3/1692753349521.png)

![1692753383913](image/基础语法3/1692753383913.png)

平衡过程推演：

![1692753397411](image/基础语法3/1692753397411.png)

红黑树：（没整懂)

![1692753423402](image/基础语法3/1692753423402.png)

各种数据结构的特点：

![1692752669860](image/基础语法3/1692752669860.png)

# Set

![1693179788050](image/基础语法3/1693179788050.png)

## Hashset

![1693179054721](image/基础语法3/1693179054721.png)

有序：体现在存的时候是acb，那么取的时候也是acb,元素之间的上下游关系是定死的

排序：体现在存的时候是放入acb，但是是以abc存储，如果是对象，需要自定义排序规则

HashSet是怎么存数据的呢？先说下hash

![1693179092826](image/基础语法3/1693179092826.png)

hashset的链表：

![1693179209312](image/基础语法3/1693179209312.png)JSK8z之前（数组+链表)，这样存储有个缺点，如果数据够多，位置3上的链表长度就会越来越长，性能也会相对变差，所以链表又可以升级成红黑树，JDK8之后变成了数组+链表+红黑树，链表存值变化如下：

![1693179385430](image/基础语法3/1693179385430.png)

因子的作用就是提前比如数组达到75%的存满状态就提前扩容，不是满了才开始扩容。

![1693179468526](image/基础语法3/1693179468526.png)

所以，当我们要存储一个对象，并且优化他的存储（重写hashCode)，以及当两个对象一模一样就认为他是一样的（比如两个对象的姓名，年龄，性别一致就认为是同一个人，那么需要重写equals方法)：

![1693179739106](image/基础语法3/1693179739106.png)

## LinkedHashSet

![1693179965268](image/基础语法3/1693179965268.png)

就是存数据的时候，元素还是按照hashset的方式进行存储，但是元素和元素之间还多了一个双链表来记录顺序

## TreeSet

![1693180536701](image/基础语法3/1693180536701.png)

demo:

![1693180600146](image/基础语法3/1693180600146.png)

![1693181009710](image/基础语法3/1693181009710.png)

### 自定义排序-方式1：

compareTo里面的比较规则：

![1693181223189](image/基础语法3/1693181223189.png)

为了防止放回0，导致数据丢失，可以这么重写：

![1693181075654](image/基础语法3/1693181075654.png)

### 自定义排序-方式2：

![1693181209706](image/基础语法3/1693181209706.png)

lamdma表达式：

![1693181498524](image/基础语法3/1693181498524.png)

同样这里返回0，也会过滤其中一个，所以这里的写法也可以像上面改造成三目运算就好了。

![1693181507134](image/基础语法3/1693181507134.png)

总结：

![1693181690030](image/基础语法3/1693181690030.png)

# 可变参数：

```java
package com.itheima.d2_params;

import java.util.Arrays;

/**
    目标：可变参数。

    可变参数用在形参中可以接收多个数据。
    可变参数的格式：数据类型...参数名称

    可变参数的作用：
         传输参数非常灵活，方便。
         可以不传输参数。
         可以传输一个参数。
         可以传输多个参数。
         可以传输一个数组。

     可变参数在方法内部本质上就是一个数组。
     可变参数的注意事项：
         1.一个形参列表中可变参数只能有一个！！
         2.可变参数必须放在形参列表的最后面！！
     小结：
        记住。
 */
public class MethodDemo {
    public static void main(String[] args) {

        sum(); // 1、不传参数
        sum(10); // 2、可以传输一个参数
        sum(10, 20, 30); // 3、可以传输多个参数
        sum(new int[]{10, 20, 30, 40, 50}); // 4、可以传输一个数组
    }

    /**
       注意：一个形参列表中只能有一个可变参数,可变参数必须放在形参列表的最后面
     * @param nums
     */
    public static void sum(  int...nums){
        // 注意：可变参数在方法内部其实就是一个数组。 nums
        System.out.println("元素个数：" + nums.length);
        System.out.println("元素内容：" + Arrays.toString(nums));
    }
}

```

# Collections集合工具类：

![1693183422915](image/基础语法3/1693183422915.png)

demo1:

```java
package com.itheima.d3_collections;

import java.util.*;

/**
    目标：Collections工具类的使用。

    java.utils.Collections:是集合工具类
    Collections并不属于集合，是用来操作集合的工具类。
    Collections有几个常用的API:
         - public static <T> boolean addAll(Collection<? super T> c, T... elements)
             给集合对象批量添加元素！
         - public static void shuffle(List<?> list) :打乱集合顺序。
         - public static <T> void sort(List<T> list):将集合中元素按照默认规则排序。
         - public static <T> void sort(List<T> list，Comparator<? super T> c):将集合中元素按照指定规则排序。
 */
public class CollectionsDemo01 {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        //names.add("楚留香");
        //names.add("胡铁花");
        //names.add("张无忌");
        //names.add("陆小凤");
        Collections.addAll(names, "楚留香","胡铁花", "张无忌","陆小凤");
        System.out.println(names);

        // 2、public static void shuffle(List<?> list) :打乱集合顺序。
        Collections.shuffle(names);
        System.out.println(names);

        // 3、 public static <T> void sort(List<T> list):将集合中元素按照默认规则排序。 （排值特性的元素）
        List<Integer> list = new ArrayList<>();
        Collections.addAll(list, 12, 23, 2, 4);
        System.out.println(list);
        Collections.sort(list);
        System.out.println(list);
    }
}

```

对象-排序：

```java
package com.itheima.d3_collections;


import java.util.*;

/**
    目标：引用数据类型的排序。

    字符串按照首字符的编号升序排序！

    自定义类型的比较方法API:Collections
         - public static <T> void sort(List<T> list):
               将集合中元素按照默认规则排序。
               对于自定义的引用类型的排序人家根本不知道怎么排，直接报错！

         - public static <T> void sort(List<T> list，Comparator<? super T> c):
                将集合中元素按照指定规则排序,自带比较器
 */
public class CollectionsDemo02 {
    public static void main(String[] args) {
        List<Apple> apples = new ArrayList<>(); // 可以重复！
        apples.add(new Apple("红富士", "红色", 9.9, 500));
        apples.add(new Apple("青苹果", "绿色", 15.9, 300));
        apples.add(new Apple("绿苹果", "青色", 29.9, 400));
        apples.add(new Apple("黄苹果", "黄色", 9.8, 500));

//        Collections.sort(apples); // 方法一：可以的，Apple类已经重写了比较规则
//        System.out.println(apples);

        // 方式二：sort方法自带比较器对象
//        Collections.sort(apples, new Comparator<Apple>() {
//            @Override
//            public int compare(Apple o1, Apple o2) {
//                return Double.compare(o1.getPrice() , o2.getPrice()); // 按照价格排序！！
//            }
//        });

        Collections.sort(apples, ( o1,  o2) ->  Double.compare(o1.getPrice() , o2.getPrice()) );
        System.out.println(apples);

    }
}


```



# Map:

![1693440838444](image/基础语法3/1693440838444.png)

## map体系：

![1693440903618](image/基础语法3/1693440903618.png)

key: 无序、不重复，可以是复杂数据类型

value: 不做任何要求，可以重复

![1693440887110](image/基础语法3/1693440887110.png)

## Map Api：

![1693440958040](image/基础语法3/1693440958040.png)

## 遍历：

### 方式1：

![1693441069838](image/基础语法3/1693441069838.png)

demo：

```java
package com.itheima.d7_map_traversal;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
    目标：Map集合的遍历方式一：键找值

    Map集合的遍历方式有：3种。
        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据遍历键找值。
        （2）“键值对”的方式遍历：难度较大。
        （3）JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）

    a.“键找值”的方式遍历Map集合。
        1.先获取Map集合的全部键的Set集合。
        2.遍历键的Set集合，然后通过键找值。
    小结：
        代码简单，需要记住!

 */
public class MapDemo01 {
    public static void main(String[] args) {
        Map<String , Integer> maps = new HashMap<>();
        // 1.添加元素: 无序，不重复，无索引。
        maps.put("娃娃",30);
        maps.put("iphoneX",100);
        maps.put("huawei",1000);
        maps.put("生活用品",10);
        maps.put("手表",10);
        System.out.println(maps);
        // maps = {huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30}

        // 1、键找值：第一步：先拿到集合的全部键。
        Set<String> keys = maps.keySet();
        // 2、第二步：遍历每个键，根据键提取值
        for (String key : keys) {
            int value = maps.get(key);
            System.out.println(key + "===>" + value);
        }

    }
}

```

### 方式2：

![1693441158510](image/基础语法3/1693441158510.png)

demo:

```java
package com.itheima.d7_map_traversal;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/**
    目标：Map集合的遍历方式。

    Map集合的遍历方式有：3种。
        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据键找值。
        （2）“键值对”的方式遍历：难度较大。
        （3）JDK 1.8开始之后的新技术：Lambda表达式。

    b.“键值对”的方式遍历：
        1.把Map集合转换成一个Set集合:Set<Map.Entry<K, V>> entrySet();
        2.此时键值对元素的类型就确定了，类型是键值对实体类型：Map.Entry<K, V>
        3.接下来就可以用foreach遍历这个Set集合，类型用Map.Entry<K, V>
 */
public class MapDemo02 {
    public static void main(String[] args) {
        Map<String , Integer> maps = new HashMap<>();
        // 1.添加元素: 无序，不重复，无索引。
        maps.put("娃娃",30);
        maps.put("iphoneX",100);
        maps.put("huawei",1000);
        maps.put("生活用品",10);
        maps.put("手表",10);
        System.out.println(maps);
        // maps = {huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30}
        /**
            maps = {huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30}
                👇
            使用foreach遍历map集合.发现Map集合的键值对元素直接是没有类型的。所以不可以直接foreach遍历集合。
                👇
            可以通过调用Map的方法 entrySet把Map集合转换成Set集合形式  maps.entrySet();
                👇
            Set<Map.Entry<String,Integer>> entries =  maps.entrySet();
             [(huawei=1000), (手表=10), (生活用品=10), (iphoneX=100), (娃娃=30)]
                              entry
                👇
            此时可以使用foreach遍历
       */
       // 1、把Map集合转换成Set集合
        Set<Map.Entry<String, Integer>> entries = maps.entrySet();
        // 2、开始遍历
        for(Map.Entry<String, Integer> entry : entries){
            String key = entry.getKey();
            int value = entry.getValue();
            System.out.println(key + "====>" + value);
        }
    }
}

```

### 方式3：（最优)

![1693441264964](image/基础语法3/1693441264964.png)

demo:

```java
package com.itheima.d7_map_traversal;

import java.util.HashMap;
import java.util.Map;
import java.util.function.BiConsumer;

/**
    目标：Map集合的遍历方式。

    Map集合的遍历方式有：3种。
        （1）“键找值”的方式遍历：先获取Map集合全部的键，再根据键找值。
        （2）“键值对”的方式遍历：难度较大。
        （3）JDK 1.8开始之后的新技术：Lambda表达式。

    c.JDK 1.8开始之后的新技术：Lambda表达式。（暂时了解）
 */
public class MapDemo03 {
    public static void main(String[] args) {
        Map<String , Integer> maps = new HashMap<>();
        // 1.添加元素: 无序，不重复，无索引。
        maps.put("娃娃",30);
        maps.put("iphoneX",100);//  Map集合后面重复的键对应的元素会覆盖前面重复的整个元素！
        maps.put("huawei",1000);
        maps.put("生活用品",10);
        maps.put("手表",10);
        System.out.println(maps);

        //  maps = {huawei=1000, 手表=10, 生活用品=10, iphoneX=100, 娃娃=30}

//        maps.forEach(new BiConsumer<String, Integer>() {
//            @Override
//            public void accept(String key, Integer value) {
//                System.out.println(key + "--->" + value);
//            }
//        });

        maps.forEach((k, v) -> {
                System.out.println(k + "--->" + v);
        });

    }
}

```

原理：

![1693441331348](image/基础语法3/1693441331348.png)

## HashMap:

![1693442159707](image/基础语法3/1693442159707.png)

存储：

![1693442229013](image/基础语法3/1693442229013.png)

对于hashmap的储存，同样当key重复的时候，也要去重，当hashmap的key是一个对象，对象是否重复，判断条件其实就是之前讲的重写equals去做的判断，所以一般equals都是去判断对象的入参是否都一样，一样就是重复的：

![1693442380045](image/基础语法3/1693442380045.png)

总结hashmap特点：

![1693442412291](image/基础语法3/1693442412291.png)

## LinkedHashMap：

![1693442545349](image/基础语法3/1693442545349.png)

demo:

```java
package com.itheima.d9_map_impl;

import java.util.LinkedHashMap;
import java.util.Map;
import java.util.TreeSet;

/**
    目标：认识Map体系的特点：按照键无序，不重复，无索引。值不做要求。
 */
public class LinkedHashMapDemo2 {
    public static void main(String[] args) {
        // 1、创建一个Map集合对象
        Map<String, Integer> maps = new LinkedHashMap<>();
        maps.put("鸿星尔克", 3);
        maps.put("Java", 1);
        maps.put("枸杞", 100);
        maps.put("Java", 100); // 覆盖前面的数据
        maps.put(null, null);
        System.out.println(maps);

    }
}

```

## TreeMap:

![1693442606085](image/基础语法3/1693442606085.png)

demo:

```java
package com.itheima.d9_map_impl;

import com.itheima.d1_collection_set.Apple;

import java.util.Comparator;
import java.util.Map;
import java.util.TreeMap;

public class TreeMapDemo3 {
    public static void main(String[] args) {
        Map<Integer, String> maps1 = new TreeMap<>();
        maps1.put(13 , "王麻子");
        maps1.put(1 , "张三");
        maps1.put(3 , "县长");
        System.out.println(maps1);

        // TreeMap集合自带排序。  可排序 不重复（只要大小规则一样就认为重复）  无索引
        Map<Apple, String> maps2 = new TreeMap<>(new Comparator<Apple>() {
            @Override
            public int compare(Apple o1, Apple o2) {
                return Double.compare(o2.getPrice() , o1.getPrice()); // 按照价格降序排序！
            }
        });
        maps2.put(new Apple("红富士", "红色", 9.9, 500), "山东" );
        maps2.put(new Apple("青苹果", "绿色", 15.9, 300), "广州");
        maps2.put(new Apple("绿苹果", "青色", 29.9, 400), "江西");
        maps2.put(new Apple("黄苹果", "黄色", 9.8, 500), "湖北");

        System.out.println(maps2);
    }
}

```

map家族特点：

![1693442726224](image/基础语法3/1693442726224.png)

## 练习map：

demo1: map的基本使用

![1693442080096](image/基础语法3/1693442080096.png)

```java
package com.itheima.d8_map_test;

import java.util.*;

/**
   需求：统计投票人数
 */
public class MapTest1 {
    public static void main(String[] args) {
         // 1、把80个学生选择的数据拿进来。
        String[] selects = {"A" , "B", "C", "D"};
        StringBuilder sb = new StringBuilder();
        Random r = new Random();
        for (int i = 0; i < 80; i++) {
            sb.append(selects[r.nextInt(selects.length)]);
        }
        System.out.println(sb);

        // 2、定义一个Map集合记录最终统计的结果： A=30 B=20 C=20 D=10  键是景点 值是选择的数量
        Map<Character, Integer> infos = new HashMap<>(); //

        // 3、遍历80个学生选择的数据
        for (int i = 0; i < sb.length(); i++) {
            // 4、提取当前选择景点字符
            char ch = sb.charAt(i);
            // 5、判断Map集合中是否存在这个键
            if(infos.containsKey(ch)){
                 // 让其值 + 1
                infos.put(ch , infos.get(ch) + 1);
            }else {
                // 说明此景点是第一次被选
                infos.put(ch , 1);
            }
        }

        // 4、输出集合
        System.out.println(infos);

    }
}

```

demo2：map的集合嵌套

![1693442847841](image/基础语法3/1693442847841.png)

```java
package com.itheima.d9_map_impl;

import java.util.*;

/**
   需求：统计投票人数
 */
public class MapTest4 {
    public static void main(String[] args) {
        // 1、要求程序记录每个学生选择的情况。
        // 使用一个Map集合存储。
        Map<String, List<String>> data = new HashMap<>();

        // 2、把学生选择的数据存入进去。
        List<String> selects = new ArrayList<>();
        Collections.addAll(selects, "A", "C");
        data.put("罗勇", selects);

        List<String> selects1 = new ArrayList<>();
        Collections.addAll(selects1, "B", "C" , "D");
        data.put("胡涛", selects1);

        List<String> selects2 = new ArrayList<>();
        Collections.addAll(selects2 , "A",  "B", "C" , "D");
        data.put("刘军", selects2);

        System.out.println(data);

        // 3、统计每个景点选择的人数。
        Map<String, Integer> infos = new HashMap<>(); // {}

        // 4、提取所有人选择的景点的信息。
        Collection<List<String>> values = data.values();
        System.out.println(values);
        // values = [[A, B, C, D], [B, C, D], [A, C]]
        //             value

        for (List<String> value : values) {
            for (String s : value) {
                // 有没有包含这个景点
                if(infos.containsKey(s)){
                    infos.put(s, infos.get(s) + 1);
                }else {
                    infos.put(s , 1);
                }
            }
        }

        System.out.println(infos);
    }
}

```

不可变Collection、Map：

集合、map内的数据不能改动，取出来你随便改

```java
package com.itheima.d1_unchange_collection;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
     目标：不可变集合。
 */
public class CollectionDemo {
    public static void main(String[] args) {
        // 1、不可变的List集合
        List<Double> lists = List.of(569.5, 700.5, 523.0,  570.5);
        // lists.add(689.0);
        // lists.set(2, 698.5);
        // System.out.println(lists);
        double score = lists.get(1);
        System.out.println(score);

        // 2、不可变的Set集合
        Set<String> names = Set.of("迪丽热巴", "迪丽热九", "马尔扎哈", "卡尔眨巴" );
        // names.add("三少爷");
        System.out.println(names);

        // 3、不可变的Map集合
        Map<String, Integer> maps = Map.of("huawei",2, "Java开发", 1 , "手表", 1);
        // maps.put("衣服", 3);
        System.out.println(maps);
    }
}

```



# Stream：

他就是一个过程工具，处理完的数据还是要转换为原来的数据类型：

流的体验：

```java
package com.itheima.d2_stream;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
   目标：初步体验Stream流的方便与快捷
 */
public class StreamTest {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        Collections.addAll(names, "张三丰","张无忌","周芷若","赵敏","张强");
        System.out.println(names);
//
//        // 1、从集合中找出姓张的放到新集合
//        List<String> zhangList = new ArrayList<>();
//        for (String name : names) {
//            if(name.startsWith("张")){
//                zhangList.add(name);
//            }
//        }
//        System.out.println(zhangList);
//
//        // 2、找名称长度是3的姓名
//        List<String> zhangThreeList = new ArrayList<>();
//        for (String name : zhangList) {
//            if(name.length() == 3){
//                zhangThreeList.add(name);
//            }
//        }
//        System.out.println(zhangThreeList);

        // 3、使用Stream实现的
        names.stream().filter(s -> s.startsWith("张")).filter(s -> s.length() == 3).forEach(s -> System.out.println(s));
    }
}

```

demo1：基础

```java
package com.itheima.d2_stream;

import java.util.*;
import java.util.stream.Stream;

/**
     目标：Stream流的获取

     Stream流式思想的核心：
                 是先得到集合或者数组的Stream流（就是一根传送带）
                 然后就用这个Stream流操作集合或者数组的元素。
                 然后用Stream流简化替代集合操作的API.

     集合获取流的API:
         (1) default Stream<E> stream();

     小结：
         集合获取Stream流用: stream();
         数组：Arrays.stream(数组)   /  Stream.of(数组);
 */
public class StreamDemo02 {
    public static void main(String[] args) {
        /** --------------------Collection集合获取流-------------------------------   */
        Collection<String> list = new ArrayList<>();
        Stream<String> s =  list.stream();

        /** --------------------Map集合获取流-------------------------------   */
        Map<String, Integer> maps = new HashMap<>();
        // 键流
        Stream<String> keyStream = maps.keySet().stream();
        // 值流
        Stream<Integer> valueStream = maps.values().stream();
        // 键值对流（拿整体）
        Stream<Map.Entry<String,Integer>> keyAndValueStream =  maps.entrySet().stream();

        /** ---------------------数组获取流------------------------------   */
        String[] names = {"赵敏","小昭","灭绝","周芷若"};
        Stream<String> nameStream = Arrays.stream(names);
        Stream<String> nameStream2 = Stream.of(names);
    }
}

```

demo2：链式操作

```java
package com.itheima.d2_stream;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Stream;

/**
     目标：Stream流的常用API
         forEach : 逐一处理(遍历)
         count：统计个数
            -- long count();
         filter : 过滤元素
            -- Stream<T> filter(Predicate<? super T> predicate)
         limit : 取前几个元素
         skip : 跳过前几个
         map : 加工方法
         concat : 合并流。
 */
public class StreamDemo03 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        // Stream<T> filter(Predicate<? super T> predicate)
        list.stream().filter(s -> s.startsWith("张")).forEach(s -> System.out.println(s));

        long size = list.stream().filter(s -> s.length() == 3).count();
        System.out.println(size);

       // list.stream().filter(s -> s.startsWith("张")).limit(2).forEach(s -> System.out.println(s));
        list.stream().filter(s -> s.startsWith("张")).limit(2).forEach(System.out::println);

        list.stream().filter(s -> s.startsWith("张")).skip(2).forEach(System.out::println);

        // map加工方法: 第一个参数原材料  -> 第二个参数是加工后的结果。
        // 给集合元素的前面都加上一个：黑马的：
        list.stream().map(s -> "黑马的：" + s).forEach(a -> System.out.println(a));

        // 需求：把所有的名称 都加工成一个学生对象。
         list.stream().map(s -> new Student(s)).forEach(s -> System.out.println(s));
//        list.stream().map(Student::new).forEach(System.out::println); // 构造器引用  方法引用

        // 合并流。
        Stream<String> s1 = list.stream().filter(s -> s.startsWith("张"));
        Stream<String> s2 = Stream.of("java1", "java2");
        // public static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)
        Stream<String> s3 = Stream.concat(s1 , s2);
        s3.distinct().forEach(s -> System.out.println(s));
    }
}

```

demo3:下面这个案例很好的说明了stream流的操作优势：

依赖1 Topperformer：

```java
package com.itheima.d2_stream;

public class Topperformer {
    private String name;
    private double money; // 月薪

    public Topperformer() {
    }

    public Topperformer(String name, double money) {
        this.name = name;
        this.money = money;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }

    @Override
    public String toString() {
        return "Topperformer{" +
                "name='" + name + '\'' +
                ", money=" + money +
                '}';
    }
}

```

依赖2 Student：

```java
package com.itheima.d2_stream;

public class Student {
    private String name;

    public Student() {
    }

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                '}';
    }
}

```

执行：

```java
package com.itheima.d2_stream;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;
public class StreamDemo04 {
    public static double allMoney ;
    public static double allMoney2 ; // 2个部门去掉最高工资，最低工资的总和
    public static void main(String[] args) {
        List<Employee> one = new ArrayList<>();
        one.add(new Employee("猪八戒",'男',30000 , 25000, null));
        one.add(new Employee("孙悟空",'男',25000 , 1000, "顶撞上司"));
        one.add(new Employee("沙僧",'男',20000 , 20000, null));
        one.add(new Employee("小白龙",'男',20000 , 25000, null));

        List<Employee> two = new ArrayList<>();
        two.add(new Employee("武松",'男',15000 , 9000, null));
        two.add(new Employee("李逵",'男',20000 , 10000, null));
        two.add(new Employee("西门庆",'男',50000 , 100000, "被打"));
        two.add(new Employee("潘金莲",'女',3500 , 1000, "被打"));
        two.add(new Employee("武大郎",'女',20000 , 0, "下毒"));

        // 1、开发一部的最高工资的员工。（API）
        // 指定大小规则了
//        Employee e = one.stream().max((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))
//                .get();
//       System.out.println(e);
        Topperformer t = one.stream().max((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))
                .map(e -> new Topperformer(e.getName(),  e.getSalary() + e.getBonus())).get();
        System.out.println(t);

        // 2、统计平均工资，去掉最高工资和最低工资
        one.stream().sorted((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))
                .skip(1).limit(one.size() - 2).forEach(e -> {
                    // 求出总和：剩余员工的工资总和
            allMoney += (e.getSalary() + e.getBonus());
        });
        System.out.println("开发一部的平均工资是：" + allMoney / (one.size() - 2));

        // 3、合并2个集合流，再统计
        Stream<Employee> s1 = one.stream();
        Stream<Employee> s2 = two.stream();
        Stream<Employee> s3 = Stream.concat(s1 , s2);
        s3.sorted((e1, e2) -> Double.compare(e1.getSalary() + e1.getBonus(),  e2.getSalary() + e2.getBonus()))
                .skip(1).limit(one.size() + two.size() - 2).forEach(e -> {
            // 求出总和：剩余员工的工资总和
            allMoney2 += (e.getSalary() + e.getBonus());
        });

        // BigDecimal
        BigDecimal a = BigDecimal.valueOf(allMoney2);
        BigDecimal b = BigDecimal.valueOf(one.size()  + two.size() - 2);
        System.out.println("开发部的平均工资是：" + a.divide(b,2, RoundingMode.HALF_UP));
    }
}

```

demo4: 将数据转换为集合或者数组：

```java
package com.itheima.d2_stream;

import java.util.*;
import java.util.function.IntFunction;
import java.util.stream.Collectors;
import java.util.stream.Stream;

/**
     目标：收集Stream流的数据到 集合或者数组中去。
 */
public class StreamDemo05 {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("张无忌");
        list.add("周芷若");
        list.add("赵敏");
        list.add("张强");
        list.add("张三丰");
        list.add("张三丰");

        Stream<String> s1 = list.stream().filter(s -> s.startsWith("张"));
        List<String> zhangList = s1.collect(Collectors.toList()); // 可变集合
        zhangList.add("java1");
        System.out.println(zhangList);

//       List<String> list1 = s1.toList(); // 得到不可变集合
//       list1.add("java");
//       System.out.println(list1);

        // 注意注意注意：“流只能使用一次”
        Stream<String> s2 = list.stream().filter(s -> s.startsWith("张"));
        Set<String> zhangSet = s2.collect(Collectors.toSet());
        System.out.println(zhangSet);

        Stream<String> s3 = list.stream().filter(s -> s.startsWith("张"));
//         Object[] arrs = s3.toArray();
        String[] arrs = s3.toArray(String[]::new); // 可以不管，拓展一下思维！！
        System.out.println("Arrays数组内容：" + Arrays.toString(arrs));

    }
}

```

# 异常：

```
目标：异常的概念和体系。

什么是异常？
     异常是程序在"编译"或者"执行"的过程中可能出现的问题。
     异常是应该尽量提前避免的。
     异常可能也是无法做到绝对避免的，异常可能有太多情况了，开发中只能提前干预！！
     异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止，开发中异常是需要提前处理的。

     研究异常并且避免异常，然后提前处理异常，体现的是程序的安全, 健壮性！！！
Java会为常见的代码异常都设计一个类来代表。

异常的体系:
     Java中异常继承的根类是：Throwable。

Throwable(根类，不是异常类)
      /              \
     Error           Exception（异常，需要研究和处理）
/            \
编译时异常      RuntimeException(运行时异常)


     Error : 错误的意思，严重错误Error，无法通过处理的错误，一旦出现，程序员无能为力了，
        只能重启系统，优化项目。
        比如内存奔溃，JVM本身的奔溃。这个程序员无需理会。

Exception:才是异常类，它才是开发中代码在编译或者执行的过程中可能出现的错误，
        它是需要提前处理的。以便程序更健壮！

Exception异常的分类:
     1.编译时异常：继承自Exception的异常或者其子类，编译阶段就会报错，
            必须程序员处理的。否则代码编译就不能通过！！

2.运行时异常: 继承自RuntimeException的异常或者其子类，编译阶段是不会出错的，它是在
            运行时阶段可能出现，运行时异常可以处理也可以不处理，编译阶段是不会出错的，
            但是运行阶段可能出现，还是建议提前处理！！
小结：
    异常是程序在编译或者运行的过程中可能出现的错误！！
    异常分为2类：编译时异常，运行时异常。
-- 编译时异常：继承了Exception,编译阶段就报错，必须处理，否则代码不通过。
-- 运行时异常：继承了RuntimeException,编译阶段不会报错，运行时才可能出现。
    异常一旦真的出现，程序会终止，所以要研究异常，避免异常，处理异常，程序更健壮!!
```

比如越界异常：

```java
public class ExceptionDemo {
    public static void main(String[] args) {
        int[] arr = {10, 20, 40};
        System.out.println(arr[0]);
        System.out.println(arr[1]);
        System.out.println(arr[2]);
        System.out.println(arr[3]);
        System.out.println("-----------程序截止---------");
    }
}
```

常见异常：

```java
package com.itheima.d4_exception_runtimeException;
/**
    拓展: 常见的运行时异常。（面试题）
         运行时异常的概念:
             继承自RuntimeException的异常或者其子类，
             编译阶段是不会出错的，它是在运行时阶段可能出现的错误，
             运行时异常编译阶段可以处理也可以不处理,代码编译都能通过！！

             1.数组索引越界异常: ArrayIndexOutOfBoundsException。
             2.空指针异常 : NullPointerException。
               直接输出没有问题。但是调用空指针的变量的功能就会报错！！
             3.类型转换异常：ClassCastException。
             4.迭代器遍历没有此元素异常：NoSuchElementException。
             5.数学操作异常：ArithmeticException。
             6.数字转换异常： NumberFormatException。

    小结：
        运行时异常继承了RuntimeException ,编译阶段不报错，运行时才可能会出现错误!
 */
public class ExceptionDemo {
    public static void main(String[] args) {
        System.out.println("程序开始。。。。。。");
        /** 1.数组索引越界异常: ArrayIndexOutOfBoundsException。*/
        int[] arr = {1, 2, 3};
        System.out.println(arr[2]);
        // System.out.println(arr[3]); // 运行出错，程序终止

        /** 2.空指针异常 : NullPointerException。直接输出没有问题。但是调用空指针的变量的功能就会报错！！ */
        String name = null;
        System.out.println(name); // null
        // System.out.println(name.length()); // 运行出错，程序终止

        /** 3.类型转换异常：ClassCastException。 */
        Object o = 23;
        // String s = (String) o;  // 运行出错，程序终止

        /** 5.数学操作异常：ArithmeticException。 */
        //int c = 10 / 0;

        /** 6.数字转换异常： NumberFormatException。 */
        //String number = "23";
        String number = "23aabbc";
        Integer it = Integer.valueOf(number); // 运行出错，程序终止
        System.out.println(it + 1);

        System.out.println("程序结束。。。。。");
    }
}

```



7
