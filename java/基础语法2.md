开始20天第2讲

# 导包：

![1691713649595](image/基础语法2/1691713649595.png)

当我们在Test文件中使用了另外一个类的比如：鼠标放到静态变量身上，IDE会自动提示option+回车，自动导包(同级不需要，不同级需要导包)

自动导包，鼠标放上去就导入，但是这个功能不好使，那就用上面的手动办法吧

![1691713817967](image/基础语法2/1691713817967.png)

当不同的package（包)存在同名的类，在同一个文件中使用时候，另外一个类就必须全路径去使用：

![1691714109960](image/基础语法2/1691714109960.png)

如果对包和类名都进行重命名操作，那么已经引用的地方IDE也能帮我们直接重命名

# 权限修饰符：

![1691714275429](image/基础语法2/1691714275429.png)

速记下就是public可以被任何地方使用，缺省 就是只能在当前包使用

# final和abstract：

![1691715133135](image/基础语法2/1691715133135.png)

![1691715887433](image/基础语法2/1691715887433.png)

场景1：比如我们的工具类，肯定希望别人是直接使用

![1691715269735](image/基础语法2/1691715269735.png)

场景2：比如我们往一个函数中传递了一个参数，不希望这个参数再被二次赋值（比如我传了一个折扣比例进来），这个时候我们就可以对这个形参进行final修饰：

![1691715712848](image/基础语法2/1691715712848.png)

场景3：关于final修饰复杂数据类型，比如类，他的内容就可以被重新修改：

![1691716075040](image/基础语法2/1691716075040.png)

场景4：final和abstract不能同时修饰一个变量、方法，当我们的一个方法被abstract修饰，肯定需要子类去实现，实现的时候会有@overrides修饰该重写方法。

场景5：可以感受下abstact在模版函数场景的使用demo：

![1691847168820](image/基础语法2/1691847168820.png)

# 常量：

![1691716390757](image/基础语法2/1691716390757.png)

# interface：

一个类可以实现多一个接口，一个接口也可以去实现多个接口，一般我们会给接口比较多的场景，将接口进行层级划分，让一个接口去实现多个接口，然后再让这个类去实现这一个接口，好处就是结构清晰。

```java
package com.wang.d1;

// 声明一个接口：体现的就是一种规范，所以这种规范肯定是公开的
// 对于接口本身而言，这种【规范】也是存在简写的，如下：
public interface ABC {
  // 定义一个常量标准写法
  public  static final String SCHE = "AHAHAHA";
  // 简写：
  String SCHEE = "JJJJ";
  // 抽象方法，需要类去实现该接口并实现该方法
  // 在接口中定义的方法并没有函数体
  public abstract void run();
  // 简写
  void run2();
}

```

JDK8后接口做了一些改动，为了扩展接口的功能又不影响目前已经规范，所以就有了下面的骚操作：

骚操作1：可以写一个类似在类中才可以调用的，带有函数体的方法

![1691848772932](image/基础语法2/1691848772932.png)

骚操作2：

![1691848902755](image/基础语法2/1691848902755.png)

骚操作3：

![1691848924829](image/基础语法2/1691848924829.png)

```java
package com.wang.d1;

// 声明一个接口：体现的就是一种规范，所以这种规范肯定是公开的
// 对于接口本身而言，这种【规范】也是存在简写的，如下：
public interface ABC {
  // 定义一个常量标准写法
  public static final String SCHE = "AHAHAHA";
  // 简写：
  String SCHEE = "JJJJ";

  // 抽象方法，需要类去实现该接口并实现该方法
  // 在接口中定义的方法并没有函数体
  public abstract void run();

  // 简写
  void run2();

  // JDK8后的骚操作1：
  //  public void test3() { // 要用default代替public
  //
  //  }
  // 该方法只能过继给实现这个接口的类的实例来进行调用
  default void test3() {
    System.out.println("djdjjd");
    getAge(); // 只能被内部调用
  }

  // JDK8后的骚操作2：
  public static void getName() { // public可以省略
    System.out.println("woww");
  }
  // JDK8后的骚操作3：
  private void getAge() {
    System.out.println(15);
  }

}

```

调用：

![1691849920272](image/基础语法2/1691849920272.png)

# 多态：

![1691970199892](image/基础语法2/1691970199892.png)

从下面的截图就能看出来，即使子类中写了和父类同名变量，再实例化后调用该变量，也是打印的父类的变量value：

![1691970519304](image/基础语法2/1691970519304.png)

多态好处：

![1691971273690](image/基础语法2/1691971273690.png)

但是多态有个缺点，如上的案例，当我们子类有一个独有的fn，但是比如Dog有看门的功能，如果再18行后面执行a.kanmen()，岂不是乌龟也需要执行，就报错了。

这个问题是有解决办法的：

![1691972095808](image/基础语法2/1691972095808.png)

demo：

![1691972270599](image/基础语法2/1691972270599.png)

所以强转之前，java建议：

![1691972320077](image/基础语法2/1691972320077.png)

![1691972367725](image/基础语法2/1691972367725.png)

因为上面代码简单，能够直接看出a是new Dog来的，但是当代码结构复杂，a的来源不容易直接看出来的时候，使用instanceof做判断还是很有必要的。

# 内部类：

![1691973573881](image/基础语法2/1691973573881.png)

内部类的种类：

![1691973784289](image/基础语法2/1691973784289.png)

## 静态内部类：

![1691973917051](image/基础语法2/1691973917051.png)![1691974023345](image/基础语法2/1691974023345.png)

![1691974075172](image/基础语法2/1691974075172.png)

如果非得内部类访问外面的实例属性，可以通过在内部类里面实例化外部类，然后再调用该实例属性、方法。

## 成员内部类：

![1691974451147](image/基础语法2/1691974451147.png)

![1691974550551](image/基础语法2/1691974550551.png)

![1691974609728](image/基础语法2/1691974609728.png)

这种更符合生活中的场景，比如人和心脏，肯定先实例出人，再实例出心脏，再调用对应的实例方法，属性。

当我们的内部类和外部类同名，怎么访问外部类的属性、方法：

![1691974904105](image/基础语法2/1691974904105.png)

## 局部内部类：

这种写法不规范，或者不常用，只作为了解。

![1691975003989](image/基础语法2/1691975003989.png)

## 匿名内部类：

这个后续用的最多，也可以看成局部内部类的简化版：

比如我们要调用一个接口的方法，这个时候就必须先实例化，再通过这个实例去调用方法，这个就比较麻烦，写法如下：

![1692013887065](image/基础语法2/1692013887065.png)

我们用匿名内部类来减少代码：

![1692013907930](image/基础语法2/1692013907930.png)

这里看着是接口进行了实例化，其实是借助匿名内部类的写法，实现了简写的方式，本质上还是对类进行的实例化，再调用实例的swim方法。

这种需要传递接口，然后传递对应实例的场景，还有一个demo如下：

![1692014051144](image/基础语法2/1692014051144.png)

# Object常用Api：

## toString：

默认我们打印一个实例，或者实例.toString()进行打印，得到的内容如图：包名@地址 的形式：

![1692014175410](image/基础语法2/1692014175410.png)

但是实际工作中，我们是希望拿到这个实例具体的属性，方法这些内容的，所以我们要对toString进行重写：

![1692014226755](image/基础语法2/1692014226755.png)

## equals：

 如果不重写他，他的用途和==一样，就是比较两个实例的地址是否相同，所以一般我们用==去比较两个实例的地址，而重写equals，来判断两个实例的内容是否相等，比如一个设备，他可能录入途径不一样，但是厂家，铭牌，型号，did等都一模一样，我们就认为通过不同途径录入进来的这个设备就是同一台设备。

如下案例是比较Student是否相同，注释掉的部分其实就是提前判断，首先传入的是Student才具有可比较的价值，手写的equals重写案例如下：

![1692014513448](image/基础语法2/1692014513448.png)

官方的自动生成效果：

![1692015094466](image/基础语法2/1692015094466.png)

疑问，为啥比较name用的是Objects.equals，而不是字符串的name.equals(...)呢？

答：担心name是null造成空指针异常，Objects.equals是在字符串equals基础上预先做了非空判断

# Objects常用Api：

Objects是Object的子类

## equals:

其实如果没有使用官方重写Ojbect.equels，还不如直接用Objects.equals来的安全

![1692015254089](image/基础语法2/1692015254089.png)

## isNull：

判断某个变量是否是null

```java
public static void main(String[] args) {
    String a = null;
    Boolean b = isNull(a);
    System.out.println(b); // true
  }
```

# StringBuilder:

特点：可以链接各种各样的数据类型，可以链式编程

![1692017103398](image/基础语法2/1692017103398.png)

性能上他是比String直接进行+操作性能好的，因为String在进行+操作的时候，是不断地在创建都丢弃对象，然后替换变量指向的新地址：

![1692017613175](image/基础语法2/1692017613175.png)

而StringBuilder是一直在一个对象中进行的操作，所以性能上会好一些

demo：

![1692017390602](image/基础语法2/1692017390602.png)

![1692017967960](image/基础语法2/1692017967960.png)

常见的api，比如翻转reverse，length，这里有一个注意点，一般我们是把Stringbuilder作为操作string的工具，它就是一个过程，最后处理完后还是要转换成Strting进行传递（toString())，而不要直接用StringBuilder进行传递。比如这里的check

# Math：

![1692018168130](image/基础语法2/1692018168130.png)

![1692018316127](image/基础语法2/1692018316127.png)

上面见到的StringBuilder，Math这些都是直接在代码中使用，不需要引包

# System：

![1692019167172](image/基础语法2/1692019167172.png)

## 时间毫秒值：

![1692019455355](image/基础语法2/1692019455355.png)

用途demo，比如我们测试一段代码的性能：

![1692019577410](image/基础语法2/1692019577410.png)

## 数组拷贝（了解)

这个System提供的拷贝方法

![1692141525237](image/基础语法2/1692141525237.png)

```java
public class Haha {
  public static int Haha1 = 222;

  // 效果：[0,0,0,0,0,0] => [0,0,40,50,60,0]
  public static void main(String[] args) {
    int[] a = {10,20,30,40,50,60,70};
    int[] b = new int[6];
    System.arraycopy(a, 3, b,2,3);
    System.out.println(Arrays.toString(b));
  }
}
```

# BigDecimal：

![1692142104135](image/基础语法2/1692142104135.png)

bigDecimal在阿里里面的使用规范：

![1692142186406](image/基础语法2/1692142186406.png)

使用bigDecimal.valueOf更好用，因为一版需要处理大数的情况，都是数字类的入参，所以bigDecimal.valueOf用的场合更多。

把大数转换成bigDecimal进行加减乘除后，最终还是要转换成普通的数据结构来进行传递，所以bigDecimal也就是一个工具，一个过程，最后在使用的时候，比如我们转成double进行打印：

![1692142445731](image/基础语法2/1692142445731.png)

# 处理时间：

## Date

手册：https://docs.oracle.com/javase/8/docs/api/java/util/Date.html

Date是JDK8以前的工具函数，目前很少使用（后面有更高级的Api)，可以看到Date目前还有两种初始化的方式还没有被废弃：

![1692143549779](image/基础语法2/1692143549779.png)

demo：

```java
import java.util.Date;
public class Haha {
  public static void main(String[] args) {
    Date d = new Date();
    System.out.println(d);
    long time = d.getTime();
    System.out.println(time);
    System.out.println(System.currentTimeMillis()); // 等同d.getTime();
    // 计算当前时间往后走1h121s的时间是多少
    long Time2 = System.currentTimeMillis();
    Time2 += (60 * 60 + 121) * 1000;
    Date Time3 = new Date(Time2);
    System.out.println(Time3);
  }
}
```

## SimpleDateFormat(格式化日期)：

包含了转成对应格式时间（format)和把对应格式时间字符串转换成时间毫秒值（parse)

手册: https://docs.oracle.com/javase/8/docs/api/java/text/SimpleDateFormat.html

### format：

![1692144992474](image/基础语法2/1692144992474.png)

![1692145047421](image/基础语法2/1692145047421.png)

具体缩写的含义可以参考文档：

![1692145091169](image/基础语法2/1692145091169.png)

对上面的【日期对象】进行格式化：

```java
import java.text.SimpleDateFormat;
import java.util.Date;
//...
SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss EEE a");
String ss = sdf.format(Time3);
System.out.println(ss); // 2023年08月16日 09:24:37 周三 上午
```

SimpleDateFormat也可以格式化时间毫秒值：

```java
    long f = System.currentTimeMillis();
    String f2 = sdf.format(f);
    System.out.println(f2); // 2023年08月16日 08:28:35 周三 上午
```

### parse：

案例：计算出2021年08月06日11点11分11秒，往后走2天14小时49分06秒后的时间是多少

```java
package com.wang.d2;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

public class Haha {
  public static void main(String[] args) throws ParseException {
    String dateStr = "2021年08月06日 11:11:11";
    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
    Date d = sdf.parse(dateStr);
//    long time = d.getTime() + (2*24*60*60 + 14*60*60 + 49*60 + 6) * 1000;
    // 下面这种写法更保险，不容易越界
    long time = d.getTime() + (2L*24*60*60 + 14*60*60 + 49*60 + 6) * 1000;
    // 再把加好的时间毫秒值再转换成对应格式的时间字符串
    String dd = sdf.format(time);
    System.out.println(dd); // 2021年08月09日 02:00:17
  }
}


```






# 包装类：

集合、泛型都不支持基本类型，所以java中也是要把基本类型转换成对象，比如int变成了Interger

# 正则：

# 数组：

# Lambda表达式：

进一步简化匿名类表达式
