## TS优势

优势1：编译时静态类型检测：函数或方法传参或变量赋值不匹配时，会出现编译错误提示 ，规避了开发期间的大量低级错误，省时，省力。

优势2：能自动提示：变量类型、变量属性，不用来回切换文件或不小心写错导致的编码隐患。

优势3： 引入了泛型：让大中项目，前端框架底层源码具备了高可扩展性这个巨大的优势，同时也有类型安全检查的优势。

优势4： 强大的 d.ts 声明文件：声明文件像一个书的目录一样，清晰直观展示了依赖库文件的接口，type类型，类，函数，变量等声明。

优势5：轻松编译成 JS 文件：即使 TS 文件有错误，绝大多数情况也能编译出 JS 文件。

优势6：灵活性高： 尽管 TS 是一门 强类型检查语言，但也提供了 any 类型 和 as any 断言，这提供了 TS的灵活度。

## 1、开发环境搭建：

```powershell
npm init -y 

yarn  add typescript -D

tsc --init
```

## 2、tsconfig的常见配置：

```js
{
  "compilerOptions": {
    "target": "es2020", // 指定 TS 编译成 JS 后的js版本 // 一般是写成 ES5
    "module": "commonjs", // TS 编译成 JS 后采用的模块规范 commonjs amd cmd  es等   
    "lib": ["DOM","ES2020"], /*  指定 TS 编码期间可以使用的库文件版本 比如：ES5就不支持Set集合 */
    "outDir": "./dist", //     指定 TS 文件编译成 JS 后的输出目录                 /* Redirect output structure to the directory. */
    "rootDir": "./src", // 指定 TS 文件源码目录
    "strict": true, // 启用严格检查模式
    "strictNullChecks":false,// null 和 undefined即是值，也是类型, null 和 undefined 值 只能赋值给 any ,unknown和它们各自的类型
    "noImplicitAny": true, // 一般是指表达式或函数参数上有隐含的 any类型时报错
    "experimentalDecorators": true, /* 启用ES7装饰器实验开启选项 */
    "emitDecoratorMetadata": true, /* 启用装饰器元数据开启选项 */
    "declaration": true, // 指定 TS 文件编译后生成相应的.d.ts文件
    "removeComments": false, // TS 文件编译后删除所有的注释
  
    "baseUrl": "src", /* 工作根目录  解析非相对模块的基地址*/
    "paths": {
        "@/datatype/*": ["datatype/*"],
        "@/131/*": ["131/*"],
        "@/132/*": ["132/*"]
      },  
    // 有些依赖库底层 为了兼容CommonJs规范、AMD规范这二者的规范中相互兼容，
    // 使用了 export =，将二者规范统一。
    // "esModuleInterop":true表示允许依赖库中出现export = 这种兼容规范导出的格式，
    //  TS 可以用import from导入 
    "esModuleInterop": true,  
  },
  "include": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题
    "./src/**/*.ts" // 匹配src下所有的ts文件
, "src/datatype/typepsenumts"  ],
   "exclude": [
    "./src/**/test",
    "./src/**/premit", 
  ]
}
```

## 3、any 和 unknown 的两个区别

- 定义为any 的变量还可以赋值给一个比如number类型(any类型可以作为别的类型的子类存在)，但是定义为unknown的类型就不能赋值给一个确定的类型，他们的包含关系：

  ![1676193565694](image/1、基础/1676193565694.png)
- 类型注释和类型推导

```ts
// 类型注解
let price: number = 3
type StudentType = { name: string, age: number }
let stuObj: StudentType = { name: "wangwu", age: 23 }

// stuObj.age  当输入stuObj.的时候就已经有提示了

// 类型推导
let count = 3;
let custObj = { name: "wangwu", age: 23 }

// custObj.name  当输入custObj.的时候就已经有提示了
```

- 推导关系

当我们使用any写法比如：

```ts
const a: any = {"name": 23}
```

我们在输入a.的时候，就不会有name的输入建议了，因为any的原因，a已经不存在类型推导，但是可以写a.name不会因为ts报错，但是我们用unknown:

```ts
const a: unknown = {"name": 23}
```

再调用a.name就会有警告：

![1676193344310](image/1、基础/1676193344310.png)

- 当我们把一个变量定义为any，那么写成any[]，和写成any代表含义一样

### 案例1：

```ts
let obj = {name: 'wang', age: 1}
let username = 'name'
obj[username]
```

第三行会报错：

Element implicitly has an 'any' type because expression of type 'string' can't be used to index type '{ name: string; age: number; }'.

原因：username可以随意变化

解决办法一：

    把username定义成const，这样就不会报错

解决办法二：

    letusername: keyoftypeofobj = 'name'


案例2：

```ts
let obj:object = {name: 'wang', age: 1}
const username = 'name'
obj[username]
```

第三行会报错：

Element implicitly has an 'any' type because expression of type '"name"' can't be used to index type '{}'.

原因：obj被object进行了类型注解，那么在执行obj[username]的时候就是从object上去找username属性，肯定找不到就报警告了

解决办法1：

```ts
let obj:object = {name: 'wang', age: 1}
const username = 'name'
let s = (obj as any)[username]
```


## 4、 BigInt

TS3.2版本后才出现的数据类型

如果使用bigInt，ts编译成js也是用的js的bigint，所以要注意bigint的兼容性

同时tsconfig.json文件中lib依赖要加上["ES2020"]

```ts
// 这种就是导致运算错误
// const max = Number.MAX_SAFE_INTEGER;
// console.log(max)
// const maxBigOne = max + 1
// console.log(maxBigOne)
// const maxBigtwo = max + 2
// console.log(maxBigtwo)
// console.log(maxBigOne === maxBigtwo)

// 这种是bigint标准写法
// const max = BigInt(Number.MAX_SAFE_INTEGER);
// console.log(max)
// const maxBigOne = max + BigInt(1)
// console.log(maxBigOne)
// const maxBigtwo = max + BigInt(2)
// console.log(maxBigtwo)
// console.log(maxBigOne === maxBigtwo)

// 这种简写的写法也ok，但是有个比较诡异的要求，tsconfig中的target必须改成"ES2020"
const max = BigInt(Number.MAX_SAFE_INTEGER);
console.log(max)
const maxBigOne = max + 1n
console.log(maxBigOne)
const maxBigtwo = max + 2n
console.log(maxBigtwo)
console.log(maxBigOne === maxBigtwo)

export { }
```


5、never应用场合

```ts
// dataFlowAnalysisWithNever 方法穷尽了 DataFlow 的所有可能类型。 
// 通过这个示例，我们可以得出一个结论：
// 使用 never 避免出现未来扩展新的类没有对应类型的实现，
// 目的就是写出类型绝对安全的代码。
type DataFlow = string | number
function dataFlowAnalysisWithNever(dataFlow: DataFlow) {
  if (typeof dataFlow === 'string') {
    console.log(dataFlow)
  } else if (typeof dataFlow === 'number') {

  } else {
    // dataFlow 在这里是 never 
    let nothings = dataFlow;//never
  }
}
dataFlowAnalysisWithNever("免税店")


export { }
```

解释：第13行，如果 DataFlow 只定义了 string | number，那么13行就是nerver情况，如果哪天dataFlow扩展了比如boolean，那么13就会变成赋值boolean的操作，就不是nerver了


5、枚举

一个比较好的应用场景，就是各种if else进行常量比较的时候引入枚举

使用：

```ts
// 字符串枚举
enum EnumAuditStatus {
  MANAGER_ADUIT_FAIL = "项目经理审核失败"
  NO_ADUIT = "没有审核"
  MANAGER_ADUIT_SUCCESS = "项目经理审核成功"
  FINAL_ADUIT_SUCCESS = "财务审核成功"
}

//  字符串枚举
enum WeekEnd {
  Monday = "1",
  Tuesday = "2",
  Wensday = "Wensday",
  ThirsDay = "ThirsDay",
  Friday = "Friday",
  Sarturday = "Sarturday",
  Sunday = "Sunday"
}
```

我们可以通过WeekEnd.Monday 取出 1，也能通过WeekEnd['1']取出Monday








-
