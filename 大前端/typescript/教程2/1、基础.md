## TS优势

优势1：编译时静态类型检测：函数或方法传参或变量赋值不匹配时，会出现编译错误提示 ，规避了开发期间的大量低级错误，省时，省力。

优势2：能自动提示：变量类型、变量属性，不用来回切换文件或不小心写错导致的编码隐患。

优势3： 引入了泛型：让大中项目，前端框架底层源码具备了高可扩展性这个巨大的优势，同时也有类型安全检查的优势。

优势4： 强大的 d.ts 声明文件：声明文件像一个书的目录一样，清晰直观展示了依赖库文件的接口，type类型，类，函数，变量等声明。

优势5：轻松编译成 JS 文件：即使 TS 文件有错误，绝大多数情况也能编译出 JS 文件。

优势6：灵活性高： 尽管 TS 是一门 强类型检查语言，但也提供了 any 类型 和 as any 断言，这提供了 TS的灵活度。

## 1、开发环境搭建：

```powershell
npm init -y 

yarn  add typescript -D

tsc --init
```

## 2、tsconfig的常见配置：

```js
{
  "compilerOptions": {
    "target": "es2020", // 指定 TS 编译成 JS 后的js版本 // 一般是写成 ES5
    "module": "commonjs", // TS 编译成 JS 后采用的模块规范 commonjs amd cmd  es等   
    "lib": ["DOM","ES2020"], /*  指定 TS 编码期间可以使用的库文件版本 比如：ES5就不支持Set集合 */
    "outDir": "./dist", //     指定 TS 文件编译成 JS 后的输出目录                 /* Redirect output structure to the directory. */
    "rootDir": "./src", // 指定 TS 文件源码目录
    "strict": true, // 启用严格检查模式
    "strictNullChecks":false,// null 和 undefined即是值，也是类型, null 和 undefined 值 只能赋值给 any ,unknown和它们各自的类型
    "noImplicitAny": true, // 一般是指表达式或函数参数上有隐含的 any类型时报错
    "experimentalDecorators": true, /* 启用ES7装饰器实验开启选项 */
    "emitDecoratorMetadata": true, /* 启用装饰器元数据开启选项 */
    "declaration": true, // 指定 TS 文件编译后生成相应的.d.ts文件
    "removeComments": false, // TS 文件编译后删除所有的注释
  
    "baseUrl": "src", /* 工作根目录  解析非相对模块的基地址*/
    "paths": {
        "@/datatype/*": ["datatype/*"],
        "@/131/*": ["131/*"],
        "@/132/*": ["132/*"]
      },  
    // 有些依赖库底层 为了兼容CommonJs规范、AMD规范这二者的规范中相互兼容，
    // 使用了 export =，将二者规范统一。
    // "esModuleInterop":true表示允许依赖库中出现export = 这种兼容规范导出的格式，
    //  TS 可以用import from导入 
    "esModuleInterop": true,  
  },
  "include": [ // 需要编译的ts文件一个*表示文件匹配**表示忽略文件的深度问题
    "./src/**/*.ts" // 匹配src下所有的ts文件
, "src/datatype/typepsenumts"  ],
   "exclude": [
    "./src/**/test",
    "./src/**/premit", 
  ]
}
```

## 3、any 和 unknown 的两个区别

- 定义为any 的变量还可以赋值给一个比如number类型(any类型可以作为别的类型的子类存在)，但是定义为unknown的类型就不能赋值给一个确定的类型，他们的包含关系：

  ![1676193565694](image/1、基础/1676193565694.png)
- 类型注释和类型推导

```ts
// 类型注解
let price: number = 3
type StudentType = { name: string, age: number }
let stuObj: StudentType = { name: "wangwu", age: 23 }

// stuObj.age  当输入stuObj.的时候就已经有提示了

// 类型推导
let count = 3;
let custObj = { name: "wangwu", age: 23 }

// custObj.name  当输入custObj.的时候就已经有提示了
```

- 推导关系

当我们使用any写法比如：

```ts
const a: any = {"name": 23}
```

我们在输入a.的时候，就不会有name的输入建议了，因为any的原因，a已经不存在类型推导，但是可以写a.name不会因为ts报错，但是我们用unknown:

```ts
const a: unknown = {"name": 23}
```

再调用a.name就会有警告：

![1676193344310](image/1、基础/1676193344310.png)

- 当我们把一个变量定义为any，那么写成any[]，和写成any代表含义一样

## 4、 BigInt

TS3.2版本后才出现的数据类型








-
