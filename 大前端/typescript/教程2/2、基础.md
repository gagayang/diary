## 继承存在的目的

避免重复定义+内存空间的浪费

以往我们的认知是把公共的属性，方法拿出来放在一个基类中，避免重复定义，其实从另外一个角度上来讲，如果是对象，数组，方法等复杂的数据类型，如果是公共的，就应该放在基类中，避免每次new都会暂用堆内存，导致空间浪费

我们将tsconfig的target输出改成"ES5":

ts：

```ts
class Person {
  name:string = 'temp-wang'
  constructor(_name: string) {
    this.name = _name
  }
  eat(what:string):void {
    console.log(`${this.name} is eat ${what}`)
  }
}

```

编译成ES5后：

```js
"use strict";
var Person = /** @class */ (function () {
    function Person(_name) {
        this.name = 'temp-wang';
        this.name = _name;
    }
    Person.prototype.eat = function (what) {
        console.log("".concat(this.name, " is eat ").concat(what));
    };
    return Person;
}());

```

可以看出方法被挂在到原型上面去了，这里决定一个引用属性是否被放到原型上，其实就是看他是否具有共性，没有共性的东西只能放在当前类上

## TS中类constructor芝士

场景1：

之前我们给class赋出数值的时候，都要先写属性，再赋值属性，写法比较臃肿，如下：

```ts
class Person {
  name:string = 'temp-wang'
  constructor(_name: string) {
    this.name = _name
  }
  eat(what:string):void {
    console.log(`${this.name} is eat ${what}`)
  }
}

```

当我们给constructor的属性加上public修饰，这个参数就变成了一个属性[隐式操作]

```ts
class Person {
  constructor(public name: string) {}
  eat(what:string):void {
    console.log(`${this.name} is eat ${what}`)
  }
}
```

场景2：

场景1中ts的简写的确简约，但是可读性不好，所以有时候还是喜欢简约的写法：

```ts
class Person {
  name:string | undefined
  constructor(_name: string) {}
}

```

当一个属性没有被constructor初始化的时候，往往他会因为TS报错，所以加上undefined的联合类型，但是加上联合类型又会导致一些别的问题，比如定义了忘记使用，使用的时候如果参与运算，它又可能是undefined的类型导致TS报错，所以在TS4.0之后又出现了另外一种写法：

```ts
class Person {
  name!:string
  constructor(_name: string) {}
}

```

即使属性没有被constructor初始化，在name后面加一个叹号也可以让TS校验通过（就是不检测了)，这个时候name就算没有被赋值，也默认是string类型

（其实这种写法也尽量要避免)



## TS中模块化检测的问题

在ts中，如果我们在一个工程中（即使不同文件)重复定义了一个变量会提示报错：

![1676774619394](image/2、基础/1676774619394.png)

因为ts会在整个工程中进行全局搜索，解决这个问题的办法就是把其中一个变成模块，比如shop.ts的最后一行加上export {}就会让这个文件的ts检测只在当前模块检测

![1676774757563](image/2、基础/1676774757563.png)


## 本地环境配置

- （1）初始化 npm init --yes 出现 package.json

- （2） 安装 typescript

    全局安装 cnpm i typescript -g     或

    本地安装： cnpm i typescript -D   或

    yarn安装 yarn global   add typescript

    【cnpm i typescript -D 是 cnpm install typescript --save-dev的缩写】

- (3）生成tsconfig.json文件

    tsc --init

- （4）修改 tsconfig.json 中的配置
  “outDir:  "./dist"     --outDir是ts编译后生成js文件保存的目录
  "rootDir": "./src", --rootDir是自己编写的ts源文件所在的目录
  注意: dist src package.json 必须是在一个目录下

- （5）编译src目录以及子目录下的ts文件

    tsc 【在src当前目录下：输入tsc   注意直接写tsc命令即可】
 		  【会把src目录以及子目录下的ts文件全部编译成js文件，并全部输出到dist目录中】

- （6）安装 ts-node

    ts-node让node能直接运行ts代码，无需使用tsc将ts代码编译成js代码。【ts-node则包装了node，它可以直接的运行ts代码】

    全局安装     cnpm i ts-node -g     或

    本地安装： cnpm i ts-node -D   或

    yarn安装：yarn global   add ts-node

- （7）安装nodemon工具 【自动检测工具】
  nodemon作用：【nodemon可以自动检测到目录中的文件更改时通过重新启动应用程序来调试基于node.js的应用程序】

    全局安装  cnpm install -g nodemon     或

    本地安装： cnpm i nodemon  -D  或

    yarn安装    yarn add nodemon  -D

- （8） 在package.json中配置自动检测，自动重启应用程序

  ```js
  "scripts": {
     "dev": "nodemon --watch src/ -e ts --exec ts-node ./src/app.ts"
  }
  ```


	nodemon --watch src/  表示检测目录是package.json同级目录src

    -e ts   表示nodemon 命令准备将要监听的是ts后缀的文件

    --exec ts-node ./src/project/app.ts 表示检测到src目录下有任何变化 都要重新执行app.ts文件

以上可以在cmd中进行调试，如果需要浏览器环境调试，可以继续如下操作：

Parcel打包支持浏览器运行TS文件（可以在index.html文件中直接引用ts文件)

    （1）安装Parcel打包工具：npm install parcel-bundler --save-dev

    （2）在package.json中给npm添加启动项，支持启动parcel工具包

```js
"scripts": {
	"start": "parcel ./index.html"
}
```

    (3)  启动parcel工具包

    cnpm run start  【cnpm start】或  npm  run start  【npm start】或 yarn run start 【yarn start】


## 函数重载

比如我们要完成下面一个功能，可以根据id或者type进行查找数据，返回的数据可能是Message或者Message[]

不用函数重载完成：

```TS
type MessageType = "image" | "audio" | string;//微信消息类型
type Message = {
  id: number;
  type: MessageType;
  sendmessage: string;
};
let messages: Message[] = [
  //let messages: Array<Message> = [
  {
    id: 1, type: 'image', sendmessage: "你好啊,今晚咱们一起去三里屯吧",
  },
  {
    id: 2, type: 'audio', sendmessage: "朝辞白帝彩云间，千里江陵一日还"
  },
  {
    id: 3, type: 'audio', sendmessage: "你好！张无忌"
  },
  {
    id: 4, type: 'image', sendmessage: "刘老根苦练舞台绝技！"
  },
  {
    id: 5, type: 'image', sendmessage: "今晚王牌对王牌节目咋样?"
  }]

// 1.函数结构不分明,可读性，可维护性变差
function getMessage(value: number | MessageType):
  Message | undefined | Array<Message> {
  if (typeof value === "number") {
    return messages.find((msg) => { return value === msg.id })
  } else {
    //return messages.filter((msg) => { return value === msg.type })
    return messages.filter((msg) => value === msg.type)
  }
}

console.log(getMessage("audio"));
// TS没有办法运行之前根据传递的值来推导方法最终返回的数据的数据类型
// 只可以根据方法定义的类型展现
//let msg=getMessage(1) 
//console.log(msg.sendMessage)//错误 类型“Message | Message[]”上不存在属性“sendMessage”。
//  类型“Message”上不存在属性“sendMessage”
let msg = (<Message>getMessage(1)).sendmessage // 强行转换类型，不推荐
console.log("msg:", msg)// msg: 你好啊,今晚咱们一起去三里屯吧


export { }
```

可以看出getMessage函数内部进行了一系列的逻辑判断，结构不分明，并且：

出参：返回的数据类型不统一，导致没办法读取sendMessage方法

入参：联合类型，会导致推导的可用方法变少，就好比我们把一个数据类型定义成：

let str:string|unmber，当我们尝试使用str的方法，就只剩下string和number交叉（共同)的方法了

![1676796541109](image/2、基础/1676796541109.png)

当然以上问题，我们可以通过明确的判断，比如对参数value通过typeof缩小范围，也可以将返回值断言或者统一成一种格式返回，终归是不够分明的，所以有了函数重载：


TODO待编辑：开始看3-7

```ts
function getMessage(value: number, myname: string): Message//第一个根据数字id来查询单个消息的重载签名
function getMessage(value: MessageType, readRecordCount: number): Message[]//第二个根据消息类型来查询消息数组的重载签名
//function getMessage(value: number | MessageType, readRecordCount: number = 1): Message | undefined | Message[] {
//function getMessage(value: any, readRecordCount: any = 1): Message | undefined | Message[] {
// function getMessage(value: number): Message //这个功能本来就没有第二个参数，所以在实现函数里面给readRecordCount加了默认值1，避免这里必须传参
//function getMessage(value: any, readRecordCount: any = 1):any { // 实现函数的入参可以写成any，因为他不知道重载函数的入参到底是什么类型，但是出参最好不要写any，因为我们可以确切的知道最终输出什么
// 并且value可以是any，unknown，但是readRecordCount可以是any不能是unkown，因为unknown是常见类型的父类，splice函数入参要求是number | undefined，不能把父类传给子类
//function getMessage(value: any, myname: string = "abc", readRecordCount: any = 1) {
function getMessage(value: any, value2: any = 1) {
  //console.log(myname)
  if (typeof value === "number") {
    return messages.find((msg) => { return 6 === msg.id })//undefined
  } else {
    //return messages.filter((msg) => { return value === msg.type })
    return messages.filter((msg) => value === msg.type).splice(0, value2)
  }
}
getMessage(1, "df")

//console.log(getMessage(6).sendmessage);
getMessage("image", 2).forEach((msg) => {
  console.log(msg);
})
```

函数重载的规则：

TS 的函数重载比较特殊，和很多其他后端语言的方法重载相比，多了不少规则。学习函数重载，先要了解什么是函数签名，定义如下：

**函数签名** [ function signature ]：函数签名=函数名称+函数参数+函数参数类型+返回值类型四者合成。在 TS 函数重载中，包含了实现签名和重载签名，实现签名是一种函数签名，重载签名也是一种函数签名。

关于函数重载的定义，我们先来看一个很多其他资料提供的不完整且模糊的TS函数重载定义：

**不完整模糊的 TS 函数重载定义**：一组具有相同名字，不同参数列表的和返回值无关的函数 。

**完整的函数重载定义**：包含了以下规则的一组函数就是TS函数重载 【规则内容多，大家要多记，多实践方可】

**规则1：**由一个实现签名+ 一个或多个重载签名合成。

**规则2：** 但外部调用函数重载定义的函数时，只能调用重载签名，不能调用实现签名，这看似矛盾的规则，其实 是TS 的规定：实现签名下的函数体是给重载签名编写的，实现签名只是在定义时起到了统领所有重载签名的作用，在执行调用时就看不到实现签名了。

**规则3：**调用重载函数时，会根据传递的参数来判断你调用的是哪一个函数

**规则4:**  只有一个函数体，只有实现签名配备了函数体，所有的重载签名都只有签名，没有配备函数体。

**规则5:  关于参数类型规则完整总结如下：**

实现签名参数个数可以少于重载签名的参数个数，但实现签名如果准备包含重载签名的某个位置的参数 ，那实现签名就必须兼容所有重载签名该位置的参数类型【联合类型或 any 或 unknown 类型的一种】。

**规则6： 关于重载签名和实现签名的返回值类型规则完整总结如下：**

必须给重载签名提供返回值类型，TS 无法默认推导。

提供给重载签名的返回值类型不一定为其执行时的真实返回值类型，可以为重载签名提供真实返回值类型，也可以提供  void 或 unknown 或 any 类型，如果重载签名的返回值类型是 void 或 unknown 或 any 类型，那么将由实现签名来决定重载签名执行时的真实返回值类型。 当然为了调用时能有自动提示+可读性更好+避免可能出现了类型强制转换，强烈建议为重载签名提供真实返回值类型。

不管重载签名返回值类型是何种类型【包括后面讲的泛型类型】，实现签名都可以返回 any 类型 或 unknown类型，当然一般我们两者都不选择，让 TS 默认为实现签名自动推导返回值类型。














-
